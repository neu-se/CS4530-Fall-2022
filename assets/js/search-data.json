{"0": {
    "doc": "Weather Station Observer Pattern Example",
    "title": "Weather Station Observer Pattern Example",
    "content": "This project contains starter code to demonstrate the observer design pattern. The starter code for this activity is located in week2-designpatterns-observer.zip . To run it on your computer, run npm install to fetch the dependencies for the project, and then run ts-node src/WeatherStation.ts (or npm run demo, if ts-node does not work), which should produce the following output: . Current conditions: 80F degrees and 65% humidity Avg/max/min temperature = 80/80/0 Heat Index: 82.95535063710001 Forecast: Improving weather on the way! Current conditions: 82F degrees and 70% humidity Avg/max/min temperature = 81/82/0 Heat Index: 86.90123306385205 Forecast: Watch out for cooler, rainy weather Current conditions: 78F degrees and 90% humidity Avg/max/min temperature = 80/82/0 Heat Index: 83.64967139559604 Forecast: More of the same . As we discussed in class, there is a lot to be improved from this design. Working in your group, modify this code so that it uses the observer pattern, with each of the various display classes as the observers, and the WeatherData as the subject object. A high-level sketch of this design is: . | Create a WeatherDataObserver interface, which defines your update method | Create an observers array in WeatherData and helper methods to register and de-register observers. Add code to notify the observers of updates when the weather data updates. | Modify each of CurrentConditionsDisplay, ForecastDisplay, HeatIndexDisplay and StatisticsDisplay to be implementors of the new observer interface. These display classes should display their information whenever the weather data is updated. | Modify WeatherStation, so that it creates the XXXDisplays, and subscribes them to the WeatherData | Update WeatherData.measurementsChanged to notify its observers of the update | Compare the output of your new program to the output you got by running the original version. Are the lines printed in the same order? Why or why not? | Can you modify the code so that the various XXXDisplay classes are all implementations of the same interface? Why might or might not this be a good idea? | . When you are done, run npm run pack to create a zip archive with your code. (Do NOT say npm pack, since that creates a .tgz, not a .zip.) . This activity is based on the running example in Chapter 2 of “Head First Design Patterns, 2nd Edition” by Robson and Freeman. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Activities/Lesson04%20Activity%20(Weather%20Station)/",
    "relUrl": "/Activities/Lesson04%20Activity%20(Weather%20Station)/"
  },"1": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"2": {
    "doc": "Announcements",
    "title": "Information about Project Final Deliverables and Posters/Demos Now Available",
    "content": "Nov 21 &middot; 0 min read The final project deliverabes were published few weeks ago. These include details regarding submission of the final project (i.e., code/testing, report, posters and demos). Canvas assingments for these are now available too. Each instructor has also provided detailed list of expectations for the final demos. Those can be viewed here. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"3": {
    "doc": "Announcements",
    "title": "Revised Project Plan and Team Project Repo Now Available",
    "content": "Oct 22 &middot; 0 min read The revised project plan is now available. Please note that there are several aspects of the assignment that have additional details compared to the preliminary plan: each condition of satisfaction must have a priority, and the work breakdown should be updated based upon your activities so far. Please also find the instructions for creating your team project repo now available on the project overview page. Following these instructions, you will create a private repository on GitHub that will start out with the solution to the individual project. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"4": {
    "doc": "Announcements",
    "title": "Teams Posted, Preliminary Project Plan Due 10/12",
    "content": "Oct 5 &middot; 0 min read Team assignments are now available on piazza, and the first team deliverable, the preliminary project plan is now available as well. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"5": {
    "doc": "Announcements",
    "title": "Individual Project Milestone 2 Posted",
    "content": "Sep 23 &middot; 0 min read The second (and final!) individual project deliverable is now available. The deliverable is due by October 19th at 11am ET. Please note that the second half of the assignment will rely on content in Modules 7 and 8; we would not recommend getting started on the React part of this deliverable until after we’ve covered that content in lecture. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"6": {
    "doc": "Announcements",
    "title": "Initial Website Launched",
    "content": "Sep 6 &middot; 1 min read On behalf of the entire instructional team (all 3 instructors and 12 TAs), welcome to the Fall 2022 edition of CS 4530! This website will contain all of the lectures, assignments and tutorials for the class. Our Canvas site contains your gradebook as well as single-sign-on links to Piazza (for discussion), GradeScope (for submitting assignments) and replicates much of the material on the class website. In advance of the first week of class, we’ve shared the calendars for each section, the first two lectures, and the first individual project deliverable. We are excited to meet you all this week! . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"7": {
    "doc": "Announcements",
    "title": "Initial Website Launched",
    "content": "Aug 11 &middot; 0 min read Welcome to the course website for CS4530, Fall 2022! Over the coming weeks, we will be populating this website (and Canvas) with more information about the course. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/announcements/",
    "relUrl": "/announcements/"
  },"8": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/",
    "relUrl": "/assignments/"
  },"9": {
    "doc": "CI/CD for Covey.Town",
    "title": "Continuous Development Pipelines for Covey.Town",
    "content": "In this activity, you will configure a continuous development pipeline using GitHub Actions, Heroku, and Netlify. Our pipeline will use GitHub Actions to build and test your Covey.Town fork. After successful compilation and testing, the pipeline will deploy the backend service to Heroku, create an optimized production build of the frontend, and deploy that frontend to Netlify. This tutorial is split up into two phases: deploying to Heroku, and then to deploy to Netlify. Only one member of each team needs to do these steps - the resulting deployment will be shared by the whole team. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/continuous-development#continuous-development-pipelines-for-coveytown",
    "relUrl": "/tutorials/continuous-development#continuous-development-pipelines-for-coveytown"
  },"10": {
    "doc": "CI/CD for Covey.Town",
    "title": "Pre-requisites",
    "content": "There are two pre-requisites for this activity: you must have a GitHub.com repository generated following our project forking instructions, and you must have a Twilio account. If you run into the error “refusing to allow an OAuth App to create or update workflow” when trying to push to GitHub, the fix is to update your saved authentication credentials for GitHub. For instance, you can follow these instructions to update your credentials in the MacOS Keychain. If all else fails, you can connect to GitHub with SSH instead of HTTPS, which will also solve this problem. This error seems to only occur when pushing a change to the GitHub Actions configuration file, so you could also side-step the problem by having a team mate push this change to GitHub instead (who may not run into this issue). Creating a Twilio account and recording the credentials . If you have not configured a Twilio account yet, follow these instructions to set one up: . | Go to Twilio’s website and sign up for an account. You do not need to provide a credit card to create a trial account, but will need to provide a cell phone number. a. When you create your account, to the question “Which Twilio product are you here to use”, answer “Video”, to “What do you plan to build…” answer “Other”, to “Preferred Language” select JavaScript, and to “Would you like Twilio to host your code?” select “No”. (It is OK to select other answers, but selecting these will bring you directly to the “programmable video” part of Twilio’s admin console. | Create an API Key: Select the “Account” menu from the top toolbar, and then select “API keys &amp; tokens”. If prompted, re-enter your password. | Take note of the “Live Credentials” in the box lower on this page. The “Account SID” and “Auth token” will be necessary for step 5. | Click “Create new API key”. Enter any descriptive name that you would like for the “friendly name”, and use the other default settings (US region, “standard” key type). Save the “SID” (this will be referenced later as the TWILIO_API_KEY_SID) and the “Secret” (this will be referenced later as the TWILIO_API_KEY_SECRET). You’ll need this for your local development environment. You can share a single Twilio account with all of the members in your team (sharing the .env file), but please be careful to avoid posting the contents of your .env file publicly anywhere - someone else might find your credentials and run out all of the free minutes on your account. To set up GitHub Actions and Heroku, we’ll need the values from your .env file - so be sure to get them working before proceeding. | Create a .env file in the services/townService directory, setting the values as follows: | . | Config Value | Description | . | TWILIO_ACCOUNT_SID | Visible on your twilio account dashboard. Starts with AC… | . | TWILIO_API_KEY_SID | The SID of the new API key you created. Starts with SK… | . | TWILIO_API_KEY_SECRET | The secret for the API key you created. | . | TWILIO_API_AUTH_TOKEN | Visible on your twilio account dashboard. | . You should now be able to start the backend and fronted in your local development environment and have functioning video chat. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/continuous-development#pre-requisites",
    "relUrl": "/tutorials/continuous-development#pre-requisites"
  },"11": {
    "doc": "CI/CD for Covey.Town",
    "title": "Set up Heroku",
    "content": "We will configure GitHub Actions to automatically deploy the backend rooms service to Heroku, after the tests have passed. This way, you can have a publicly available version of your backend service, which will automatically update with any changes that you push to Git. Note that it is possible to set up Heroku to automatically deploy every new change that you push to GitHub (without setting up GitHub Actions). Instead, we’ll configure our GitHub Actions pipeline to deploy to Heroku only if our test suite passes. | Go to Heroku.com and create an account, or sign in if you already have one | Enroll in the Heroku for students offer, if you have not already. | After signing in, create a new app. Choose a name for your app that is somewhat descriptive - it will become part of the URL that you’ll use to access the service. Click “Create app” (no need to go through “Add to pipeline…”). | After creating your app on Heroku, open the app’s settings page, revealing a page that looks like this: | Click “Reveal Config Vars”, and enter the 4 twilio configuration variables from your .env file (the same 4 that you set up on GitHub Actions). Heroku’s “Config Vars” are the way that we tell Heroku what variables to use for .env without having to commit that file into the (publicly viewable) repository. Your configuration settings on Heroku should look like this now: | Before navigating away from this settings page, scroll down to “Domains”, and take note of the address that Heroku has provided for your app. This should say something like “Your app can be found at https://covey-deployment-example.herokuapp.com/”. | Retrieve your personal Heroku API key. From Heroku go to “Manage Account” (click on the profile menu on the top right of the page and then click “Account Settings”. Scroll down to “API Key” and click “Reveal”. Copy this key, you’ll use it in the next step. | Return to the GitHub Settings -&gt; Secrets -&gt; Actions pane, and add a new repository secret: HEROKU_API_KEY, setting the value to the exact string that you copied from “API Key” in the last step. Add the secret HEROKU_APP_NAME (in this example, our app name is covey-deployment-example), set to the name that you choose for your Heroku app in step 2. Add the secret HEROKU_EMAIL, set to the email address that you used when you created your Heroku account. Even though these last two values aren’t secret per-say, configuring them in this way keeps them out of the config files, so you won’t run into merge conflicts with our upstream branch (which would have a main.yml file with our own settings in it). | Update the CI workflow (the file .github/workflows/main.yml). The starter code has the Heroku deploy commented out: uncomment it. If you see the line if: github.ref == 'refs/heads/master' in the file, update it to match as below (refs/heads/main). | Return to your GitHub Actions page, and the detail view for the most recent build - retrigger it, so that it runs again. Now that we have the Heroku secrets installed, we expect the “Deploy to Heroku” aspect of the deployment job to pass, although the “deploy to netlify” task will still fail. Here is the segment of the GitHub Actions configuration file that deploys our app to Heroku: . deploy: if: github.ref == 'refs/heads/main' needs: build-and-test runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: akhileshns/heroku-deploy@v3.12.12 # Deploy to Heroku action with: heroku_api_key: ${{secrets.HEROKU_API_KEY}} heroku_app_name: ${{secrets.HEROKU_APP_NAME}} heroku_email: ${{secrets.HEROKU_EMAIL}} . | To confirm that your service is successfully deployed, try to visit it in your browser. Use the URL that you noted in step 5 (“Your app can be found at https://covey-deployment-example.herokuapp.com/”). Append towns to the URl, and visit it in your browser (e.g. https://covey-deployment-example.herokuapp.com/towns). After a short delay, you should see the response []. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/continuous-development#set-up-heroku",
    "relUrl": "/tutorials/continuous-development#set-up-heroku"
  },"12": {
    "doc": "CI/CD for Covey.Town",
    "title": "Set up Netlify",
    "content": "Note 11/10: Due to an apparently “known limitation” with Netlify’s API, it took 4 days to send out all of the invitations. Everyone should now have received an invitation. Be sure to create your account using your @northeastern.edu email (which might require you to “signup” for a Netlify account with that email instead of sign in with GitHub). The last step to our continuous development pipeline will be to automatically deploy our frontend to Netlify. Netlify will create an optimized production build of your frontend (by running npm run build) and host it in their globally-distributed content delivery network. Netlify will also automatically build an deploy previews of pull requests on your repository. | Use the invitation that you received to your @northeastern.edu account to create an account on Netlify and join our organization. Netlify no longer offers a free product for private repositories - you will need to use our organization to create your site | After logging in, select the site that corresponds to your team name, and then click “Deploy your site” followed by “Deploy Settings.” Select “Link repository” and follow the prompts to connect Netlify with GitHub. Choose the “neu-cs4530” organization (you might need to click “Add another organization” in the dropdown to find it, and then select your repository. Leave “branch to deploy” as “main”. Leave the base directory unset, and set the build command to CI= npm install &amp;&amp; cd frontend &amp;&amp; npm run-script build, and the publish directory to frontend/build. Click deploy site. | Click on “Site Settings” and scroll down to “Environment”. This is where we define the .env variables that Netlify should use (without needing to put .env in a publicly viewable place). Click “Edit variables” and add a single variable: REACT_APP_TOWNS_SERVICE_URL should be set to your heroku server name (https://yourapp-name.herokuapp.com, find in heroku “settings” page for your app). Click save. | The very first deploy that was triggered will not have this environmental variable set, and hence the resulting build won’t actually be functional. Cancel the build if it is still in progress, and then click “trigger build” to trigger a new build. Once you confirm that it builds correctly, it will always auto-build and deploy without needing this intervention. | Netlify will take several minutes to build your site. From the “Deploys” view of Netlify’s control panel, you can see the status of each build. Once you have a successful build, it will show a URL where your site is published (something like https://fall-22-team-project-group-999.netlify.app). Visit the site and confirm that it’s working. If you see an error in the JavaScript log like process is not defined, this indicates that the site was not built with the REACT_APP_TOWNS_SERVICE_URL variable set - confirm that it is correctly set, and then rebuild the site on Netlify. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/continuous-development#set-up-netlify",
    "relUrl": "/tutorials/continuous-development#set-up-netlify"
  },"13": {
    "doc": "CI/CD for Covey.Town",
    "title": "CI/CD for Covey.Town",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/continuous-development",
    "relUrl": "/tutorials/continuous-development"
  },"14": {
    "doc": "CS4530, Fall 2022",
    "title": "CS4530, Fall 2022: Fundamentals of Software Engineering",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/#cs4530-fall-2022-fundamentals-of-software-engineering",
    "relUrl": "/#cs4530-fall-2022-fundamentals-of-software-engineering"
  },"15": {
    "doc": "CS4530, Fall 2022",
    "title": "Information about Project Final Deliverables and Posters/Demos Now Available",
    "content": "Nov 21 &middot; 0 min read The final project deliverabes were published few weeks ago. These include details regarding submission of the final project (i.e., code/testing, report, posters and demos). Canvas assingments for these are now available too. Each instructor has also provided detailed list of expectations for the final demos. Those can be viewed here. Announcements . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/",
    "relUrl": "/"
  },"16": {
    "doc": "CS4530, Fall 2022",
    "title": "Overview",
    "content": "Building, delivering and maintaining successful software products requires more than being good at programming. Software engineering encompasses the tools and processes that we use to design, construct and maintain programs over time. Software engineering has been said to consider the “multi person development of multi version programs.” Development processes that work well for a single developer do not scale to large or even medium-sized teams. Similarly, development processes that work well for quickly delivering a one-off program to a client cause chaos when applied to a codebase that needs to be maintained and updated over months and years. This class will begin to explore these tradeoffs throughout the entire software development lifecycle, with a particular focus on how these decisions affect the quality of the resulting software. This class will serve as an introduction to the field of software engineering, covering key topics such as: . | Requirements gathering and specification How to make sure that you build the product that your customer really wants | Designing code for reuse, for readability, and for scale How to avoid reinventing the wheel? What makes code readable? Where does performance fit into designs? When do we decide when to revisit old design decisions, and how do we replace them? Can we avoid the mistakes that past developers have made? | How to organize your development process to collaborate effectively How do we communicate our designs with others? How do we structure and coordinate development activities? How do we measure the performance of these processes, and tweak them over time? | How to ensure that your code works, is secure, and broadly speaking, “does the right thing” How do we measure different quality attributes like usability, scalability and performance? How do we minimize the cost of defects? How do we automatically test complex systems? Can we automatically prove the absence of some kinds of defects? | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/#overview",
    "relUrl": "/#overview"
  },"17": {
    "doc": "CS4530, Fall 2022",
    "title": "Course Outcomes",
    "content": ". | Students will be able to define and describe the phases of the software engineering lifecycle (requirements, design, implementation, testing, deployment, maintenance) | Students will be able to explain the role of key processes and technologies in modern software development. | Students will be able to productively apply instances of major tools used in elementary SE tasks. | Students will design and implement a portfolio-worthy software engineering project in a small team environment that can be publicly showcased to recruiters. | . Course Delivery . The course will be delivered in a “traditional” lecture style. Prof Wand’s section will be entirely virtual, and the other sections will be entirely on-the-ground, with no virtual participation option. You must attend the section for which you have registered, and you may not partner with students in other sections for the term project. | Section | Instructor | Meeting Time | Meeting Place | . | 2 | Prof Bhutta | MR 11:45 am - 1:25 pm | West Village G 106 | . | 3 | Prof Bhutta | MW 2:50 pm - 4:30 pm | Cargill Hall 097 | . | 4 | Prof Bell | TF 9:50 am - 11:30 am | Robinson Hall 109 | . | 5 | Prof Wand | R 6:00 pm - 9:20 pm | Online | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/#course-outcomes",
    "relUrl": "/#course-outcomes"
  },"18": {
    "doc": "CS4530, Fall 2022",
    "title": "Course Project",
    "content": "The assignments and project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement a new feature. The codebase that we’ll be developing on is a remote collaboration tool called Covey.Town. Covey.Town provides a virtual meeting space where different groups of people can have simultaneous video calls, allowing participants to drift between different conversations, just like in real life. Covey.Town is inspired by existing products like Gather.Town, Sococo, and Gatherly.IO — but it is an open source effort, and the features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. At the end of the semester, the instructors and TAs will evaluate all of the student projects, and select the best (in terms of usability, code quality, test suite quality, and overall design) to merge into the open source Covey.Town codebase on GitHub repository. No additional course credit will be awarded to these teams, but these students will have the opportunity to receive public recognition for their project (in the form of a pull request merged into our repository and acknowledgements in the project’s contributors list). The project will provide hands-on experience to complement the skills taught in this class, requiring students to be able to: . | Work effectively in a small team | Enumerate and prioritize development tasks | Propose, design, implement and test a new feature in an existing non-toy software application | Write code that their team members can read and review | Review teammates’ code | Analyze a proposed software architecture | Use relevant software tools, such as: . | TypeScript | Visual Studio Code (or similar IDE) | Git | Mocha and Jest | Twilio’s Programmable Video API | Postman | . | . Select projects from Spring 2022 are hosted in our project showcase. Acknowledgements . This class and its contents were inspired by Software Engineering courses at various institutions, including: . | Columbia’s Software Engineering Course, COMS W4156 | CMU’s Software Engineering Course, 17-313 | GMU’s Web App Development Course, SWE 432 | NCSU’s Software Engineering Course, CSC 326 and its iTrust term project, also Chris Parnin’s DevOps course. | Past iterations of CS4530 at Northeastern: Spring 2022, Spring 2021 | Past iterations of CS5500 at Northeastern, as prepared by Mike Weintraub, Mike Shah and Frank Tip. | . This website is built using Kevin Lin’s Just the Class Jekyll template. The term project, Covey.Town, is built using code from the Clowdr open source project. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/#course-project",
    "relUrl": "/#course-project"
  },"19": {
    "doc": "CS4530, Fall 2022",
    "title": "CS4530, Fall 2022",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/",
    "relUrl": "/"
  },"20": {
    "doc": "Individual Project 1",
    "title": "Objectives of this assignment",
    "content": "The objectives of this assignment are to: . | Get you familiar with the basics of TypeScript, VSCode, and the project codebase | Learn how to read and write code in TypeScript | Translate high-level requirements into code | Learn how to write unit tests with Jest | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#objectives-of-this-assignment",
    "relUrl": "/assignments/ip1#objectives-of-this-assignment"
  },"21": {
    "doc": "Individual Project 1",
    "title": "Changelog",
    "content": ". | 9/9/22: Added clear instructions to run eslint | 9/12/22: Clarified which properties to use for fromMapObject | 9/13/22: Added note about integration tests in part 4 | 9/15/22: Added further clarification that students should not attempt to replicate the integaration tests in their test suite | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#changelog",
    "relUrl": "/assignments/ip1#changelog"
  },"22": {
    "doc": "Individual Project 1",
    "title": "Getting started with this assignment",
    "content": "Before you begin, be sure to check that you have NodeJS 16.x installed, along with VSCode. We have provided a tutorial on setting up a development environment for this class Start by downloading the starter code. Extract the archive and run npm install to fetch the dependencies. Avery has provided you with some very basic sanity tests that you can extend for testing your implementation as you go. Overview of relevant classes . The UML class diagram below shows the three main classes that you will be implementing for this deliverable (InteractableArea, ViewingArea, and ConversationArea), along with several relevant classes that you will need to interact with. For Town and ServerToClientEvents, we show only the most relevant methods. %%{init: { 'theme':'forest', } }%% classDiagram class InteractableArea { +string id ~Player[] _occupants +string[] occupantsByID +boolean isActive +BoundingBox boundingBox +add(player: Player) +remove(player: Player) +addPlayersWithinBounds(allPlayers: Player[]) +toModel() +contains(location: PlayerLocation) +overlaps(otherInteractable: Interactable) #_emitAreaChanged() } class ViewingArea { +string video +number progress +boolean isPlaying +updateModel(updatedModel:ViewingAreaModel) +fromMapObject(mapObject, townEmitter) } class ConversationArea { +string? topic +fromMapObject(mapObject, townEmitter) } class BoundingBox { +number x +number y +number width +number height } class Player { +PlayerLocation location +string id +string username } class PlayerLocation { +number x +number y +Direction rotation +boolean moving +string? interactableID } class Town { +string townID +string friendlyName +InteractableArea[] interactables +Player[] players +void initializeMap(mapFile: string) } class TownEmitter { +void emit(eventName: ServerToClientEvents, eventData) } class ServerToClientEvents { +void playerMoved(movedPlayer: Player) +void interactableUpdate(updatedInteractable: Interactable) } ViewingArea ..|&gt; InteractableArea ConversationArea ..|&gt; InteractableArea InteractableArea o-- BoundingBox InteractableArea o-- Player InteractableArea o-- TownEmitter Player o-- PlayerLocation Town o-- Player Town o-- InteractableArea Town o-- TownEmitter TownEmitter -- ServerToClientEvents ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#getting-started-with-this-assignment",
    "relUrl": "/assignments/ip1#getting-started-with-this-assignment"
  },"23": {
    "doc": "Individual Project 1",
    "title": "Grading",
    "content": "This submission will be scored out of 100 points, 90 of which will be automatically awarded by the grading script, with the remaining 10 manually awarded by the course staff. Your code will automatically be evaluated for linter errors and warnings. Submissions that have any linter errors will automatically receive a grade of 0. Do not wait to run the linter until the last minute. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. Your code will be automatically evaluated for functional correctness by a test suite that expands on the core tests that are distributed in the handout. Your tests will be automatically evaluated for functional correctness by a process that will inject bugs into our reference solution: to receive full marks your tests must detect a minimum number of injected bugs. You will not receive detailed feedback on which injected bugs you do or do not find, and you will not receive detailed feedback on which tests you do or do not pass. The autograding script will impose a strict rate limit of 5 submissions per 24 hours. Submissions that fail to grade will not count against the quota. This limit exists to encourage you to start early on this assignment: students generally report that assignments like this take between 3-20 hours. If you start early, you will be able to take full advantage of the resources that we provide to help you succeed: office hours, discussion on Piazza — and the ability to have a greater total number of submission attempts. Your code will be manually evaluated for conformance to our course style guide. This manual evaluation will account for 10% of your total grade on this assignment. We will manually evaluate your code for style on the following rubric: . To receive all 10 points: . | All new names (e.g. for local variables, methods, and properties) follow the naming conventions defined in our style guide | There are no unused local variables | All public properties and methods (other than getters, setters, and constructors) are documented with JSDoc-style comments that describes what the property/method does, as defined in our style guide | The code and tests that you write generally follows the design principles discussed in week one. In particular, your design does not have duplicated code that could have been refactored into a shared method. | . We will review your code and note each violation of this rubric. We will deduct two points for each violation, up to a maximum of deducting all 10 style points. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#grading",
    "relUrl": "/assignments/ip1#grading"
  },"24": {
    "doc": "Individual Project 1",
    "title": "Implementation Tasks",
    "content": "This deliverable has four parts; each part will be graded on its own rubric. You should complete the assignment one part at a time, in the order presented here: . Task 1: Implement and test the abstract class (34 points total) . Your first objective is to implement the abstract class InteractableArea. Avery has provided a skeleton for this class, specifying the properties that are expected and implementing the constructor. There are six methods for you to implement in this class: add, remove, contains, addPlayersWithinBounds and overlaps (we suggest implementing them in this order). The specification for each method is provided in comments in the file, and reproduced below: . View the specification for these methods /** * Adds a new player to this interactable area. * * Adds the player to this area's occupants array, sets the player's * interactableID, informs players in the town that the player's * interactableID has changed, and informs players in the town that * the area has changed. * * Assumes that the player specified is a member of this town. * * @param player Player to add */ public add(player: Player): void; /** * Removes a player from this interactable area. * * Removes the player from this area's occupants array, clears the player's * interactableID, informs players in the town that the player's interactableID * has changed, and informs players in the town that the area has changed * * Assumes that the player specified is an occupant of this interactable area * * @param player Player to remove */ public remove(player: Player): void; /** * Tests if a player location is contained within this InteractableArea. * * This interactable area contains a PlayerLocation if any part of the player * is within any part of this area. * A PlayerLocation specifies only the center (x,y) coordinate of the player; * the width and height of the player are PLAYER_SPRITE_WIDTH and * PLAYER_SPRITE_HEIGHT, respectively * * @param location location to check * * @returns true if location is within this area */ public contains(location: PlayerLocation): boolean; /** * Given a list of players, adds all of the players that are within this * interactable area * * @param allPlayers list of players to examine and potentially add to this * interactable area */ public addPlayersWithinBounds(allPlayers: Player[]); /** * Tests if another InteractableArea overlaps with this . Two InteractableArea's * overlap if it is possible for one player to overlap with both of them * simultaneously. That is: There is an overlap if the rectangles of the two * InteractableAreas overlap, where the rectangles are expanded by * PLAYER_SPRITE_WIDTH/2 in each X dimension and PLAYER_SPRITE_HEIGHT/2 in each Y * dimension. * * @param otherInteractable interactable to checko * * @returns true if a player could be contained within both InteractableAreas * simultaneously */ public overlaps(otherInteractable: InteractableArea): boolean; /** * Emits an event to the players in the town notifying them that this * InteractableArea has changed, passing the model for this * InteractableArea in that event. */ protected _emitAreaChanged(); . Testing: Avery has provided you with test cases for add and remove, as well as some very simple (and incomplete) tests for contains and overlaps. You can run these tests by running the command npx jest --watch InteractableArea, which will automatically re-run the tests as you update the file. You should add tests for addPlayersWithinBounds, and improve the contains and overlaps tests to consider all of the boundary conditions. Please implement these additional tests in the file src/town/InteractableArea.test.ts. Grading for implementation tasks: . | add: 3 points | remove: 3 points | contains: 4 points | addPlayersWithinBounds: 3 points | overlaps: 4 points | . Grading for testing tasks: . | addPlayersWithinBounds: 3 points | contains: . | 7 points for detecting all 10 faults, or | 2 points for detecting at least 3 faults | . | overlaps . | 7 points for detecting all 12 faults, or | 5 points for detecting at least 8 faults | . | . Task 2: Implement and test the ConversationArea (15 points total) . Now that we have the core functionality for the InteractableArea abstraction implemented, we can move on to implement one of its concrete instantiations: the ConversationArea. The ConversationArea specialized the InteractableArea, storing a topic field to represent the current topic of the conversation, which is included in the corresponding ConversationAreaModel. The ConversationArea has the same semantics for add(Player) as its generic supertype, and adds a special behavior to the remove(Player) method. When the last player exits a ConversationArea, the topic field for that ConversationArea should be reset to undefined, and an update should be emitted to players in the town (by invoking this._emitAreaChanged()). For this task, Avery has provided the complete test suite for remove, however, you will need to provide a complete set of tests for toModel and fromMapObject. Please add these tests to the existing test suite in src/town/ConversationArea.test.ts. You can run these tests by running the command npx jest --watch ConversationArea, which will automatically re-run the tests as you update the file. View the specification for these methods /** * Convert this ConversationArea instance to a simple ConversationAreaModel * suitable for transporting over a socket to a client. */ public toModel(): ConversationAreaModel; /** * Removes a player from this conversation area. * * Extends the base behavior of InteractableArea to set the topic of this * ConversationArea to undefined and emit an update to other players in the * town when the last player leaves. * * @param player */ public remove(player: Player); /** * Creates a new ConversationArea object that will represent a Conversation Area * object in the town map. * * @param mapObject An ITiledMapObject that represents a rectangle in which this * conversation area exists * @param broadcastEmitter An emitter that can be used by this conversation area * to broadcast updates * @returns */ public static fromMapObject(mapObject: ITiledMapObject, broadcastEmitter: TownEmitter): ConversationArea; . (Added 9/12) fromMapObject should create the BoundingBox from the mapObject using its fields: x, y, width, height. The id of the corresponding InteractableArea should match the name property of the mapObject. If it is helpful: fromMapObject may throw an error if the mapObject is invalid. Grading for implementation tasks: . | toModel: 3 points | remove: 3 points | fromMapObject: 3 points | . Grading for testing tasks: . | toModel: 3 points | fromMapObject: 3 points | . Task 3: Implement and test the ViewingArea (21 points total) . The ViewingArea specializes InteractableArea to store the state of the viewing area, these three properties: video (a string, representing the URL of the video to be played or undefined if none is set), isPlaying (a boolean, representing whether the video should be shown as playing or paused), and elapsedTimeSec (a number, representing the number of seconds elapsed in the playback of the video). Like the ConversationArea, the ViewingArea specializes the behavior of remove, in this case setting the video property to undefined and emitting this update to the players in the town when the last player leaves the ViewingArea. The ViewingArea also adds a new method, updateModel, which will be used in the next deliverable to apply updates to the ViewingAreas state while clients are playing videos. Avery has again provided a complete test suite for remove, and will expect you to provide a complete set of tests for updateModel, toModel and fromMapObject. Please add these tests in the src/town/ViewingArea.test.ts file. You can run these tests by running the command npx jest --watch ViewingArea, which will automatically re-run the tests as you update the file. View the specification for these methods /** * Removes a player from this viewing area. * * When the last player leaves, this method clears the video of this area and * emits that update to all of the players * * @param player */ public remove(player: Player): void; /** * Updates the state of this ViewingArea, setting the video, isPlaying and progress properties * * @param viewingArea updated model */ public updateModel({ isPlaying, progress, video }: ViewingAreaModel); /** * Convert this ViewingArea instance to a simple ViewingAreaModel suitable for * transporting over a socket to a client. */ public toModel(): ViewingAreaModel; /** * Creates a new ViewingArea object that will represent a Viewing Area object in the town map. * @param mapObject An ITiledMapObject that represents a rectangle in which this viewing area exists * @param townEmitter An emitter that can be used by this viewing area to broadcast updates to players in the town * @returns */ public static fromMapObject(mapObject: ITiledMapObject, townEmitter: TownEmitter): ViewingArea; . (Added 9/12) fromMapObject should create the BoundingBox from the mapObject using its fields: x, y, width, height. The id of the corresponding InteractableArea should match the name property of the mapObject. If it is helpful: fromMapObject may throw an error if the mapObject is invalid. Grading for implementation tasks: . | remove: 3 points | updateModel: 3 points | toModel: 3 points | fromMapObject: 3 points | . Grading for testing tasks: . | updateModel: 3 points | toModel: 3 points | fromMapObject: 3 points | . Task 4: Implement and test createInteractablesFromMap (20 points total) . Your last task for this deliverable is to implement a function to validate the InteractableAreas defined in the town’s map file and populate the Town with instances of ViewingArea and ConversationArea to represent those areas. Implement this function in the method initializeFromMap in src/town/Town.ts. Avery has provided you with a single test case that you can use to check your progress; you will find that it tests some basic functionality of this function, but does not test the full specification. Please add new tests in the same describe block as the existing one in src/town/Town.test.ts. You can run these tests by running the command npx jest --watch Town.test, which will automatically re-run the tests as you update the file. Hint: The function takes as a parameter an ITiledMap object; you can learn more about the structure from reviewing the type definition, from the Tiled JSON Map Format Specification, and from the example provided in the test case for initializeFromMap in the handout. The specific layer of the map that you are looking for will be of the type ITiledMapObjectLayer. The object layer will list all of the objects. The type property of each object in that layer identifies it as a ViewingArea, ConversationArea, or other - you can ignore any others. Note (9/13/22): The grading script will also run two integration tests as part of grading this task. The integration tests will check for the behavior of every single one of the methods that you were required t complete for this and the other tasks. While we aim to create test suites for each individual implementation task that are perfect, this is at times a difficult task, and these two integration tests check how the different units interact. These two tests are clearly identified as integration tests in the grading output. Note (9/15/22): Do not try to replicate these integration tests in your tests for initializeFromMap. We will only grade your tests for initializeFromMap on their ability to find defects in our implementation of initializeFromMap, and not in any other functions. Grading: . | 10 points for a correct implementation | 10 points for tests: . | 10 points for detecting all 15 faults, or | 5 points for detecting at least 6 faults, or | 3 points for detecting at least 1 fault | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#implementation-tasks",
    "relUrl": "/assignments/ip1#implementation-tasks"
  },"25": {
    "doc": "Individual Project 1",
    "title": "Submission Instructions",
    "content": "Submit your assignment in GradeScope. The easiest way to get into GradeScope the first time is to first sign into Canvas and then click the link on our course for “GradeScope”. You should then also have the option to create an account on GradeScope (if you don’t already have one) so that you can log in to GradeScope directly. Please contact the instructors immediately if you have difficulty accessing the course on GradeScope. To submit your assignment: upload only the files: . | src/town/InteractableArea.ts | src/town/InteractableArea.test.ts | src/town/ConversationArea.ts | src/town/ConversationArea.test.ts | src/town/ViewingArea.ts | src/town/ViewingArea.test.ts | src/town/Town.test.ts | src/town/Town.ts | . The grading script should also accept your submission if you upload only a subset of these files. GradeScope will provide you with feedback on your submission, but note that it will not include any marks that will be assigned after we manually grade your submission for code style (it will show 0 for this until it is graded). It may take several minutes for the grading script to complete. GradeScope is configured to only provide feedback on at most 5 submissions per-24-hours per-student (submissions that fail to run or receive a grade of 0 are not counted in that limit). We strongly encourage you to lint and test your submission on your local development machine, and not rely on GradeScope for providing grading feedback - relying on GradeScope is a very slow feedback loop. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1#submission-instructions",
    "relUrl": "/assignments/ip1#submission-instructions"
  },"26": {
    "doc": "Individual Project 1",
    "title": "Individual Project 1",
    "content": "Welcome aboard to the Covey.Town team! We’re glad that you’re here and ready to join our development team as a new software engineer. We’re building an open source virtual meeting application, and are very happy to see that we have so many new developers who can help make this application a reality. By the end of the semester, you’ll be able to propose, design, implement and test a new feature for our project. We understand that some of you may have some web development experience, but don’t expect that most of you do, and hence, have created an individual project to help you get up to speed with our existing codebase and development environment. Covey.Town is a web application that consists of some code that runs in each client’s web browser, and also code that runs on a server. Users join the application in a “town”: a 2D arcade-style map with different rooms to explore. Each town is also a video call: when two players get close to each other, they can see and hear each other; there is also a text chat available within the town. In Winter of 2021, our lead software engineer, Avery, developed a prototype for Covey.Town, and since then, hundreds of students in this class have built on that codebase. The most recent class-wide effort added a concept called Conversation Areas, allowing players to post a textual description of the topic of their conversation, and making those video conversations private to those players standing within that same area. Many student projects in Spring 2022 (some of which are publicly showcased) involved creating other kinds of flexible interactions that involve objects in the arcade game, other elements displayed in the browser, and video chat. For example: students created game areas, where players who approached a game board could play a simple game (like tic-tac-toe) together; others created bulletin boards that stored persistent messages; others created viewing areas that allowed multiple players to simultaneously playback the same video as a “watch party.” . After studying all of the student projects and their implementation challenges, our lead software engineer, Avery, has refactored Covey.Town, designing a new abstraction to make it easier to create features like these. Avery’s new abstraction, InteractableArea, is a region of the town that provides some interactive elements for players when they enter. The abstraction cuts across the entire technology stack: InteractableAreas exist in the 2D map and the application automatically tracks when players enter and exit them. By pressing the spacebar within an InteractableArea, the user can trigger an interaction with that area, which in turn can be easily used to display new content in the web app using React. An InteractableArea in one user’s browser can also emit events that are delivered in real-time to other players interacting with that same area. The objective for this semester’s individual project is to implement this new InteractableArea abstraction, with two concrete implementations: ConversationArea and ViewingArea. While the ConversationArea will be implemented by refactoring last semester’s code to use the new interface, the ViewingArea is a new concept. The ViewingArea allows players to have “watch parties”: each player who is within the ViewingArea sees the same streaming video. If one player pauses the video, it pauses for all other players watching it, and the playback is synchronized between all players watching the video. This implementation effort will be split across two deliverables. In this first deliverable, you will implement and test the core backend components for this feature, and in the second deliverable, you will connect these new components to the rest of the backend, and implement and test the frontend components. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip1",
    "relUrl": "/assignments/ip1"
  },"27": {
    "doc": "Individual Project 2",
    "title": "Objectives of this assignment",
    "content": "The objectives of this assignment are to: . | Write new TypeScript code that uses asynchronous operations | Write test cases that utilize mocks and spies | Write React components and hooks that make use of state | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2#objectives-of-this-assignment",
    "relUrl": "/assignments/ip2#objectives-of-this-assignment"
  },"28": {
    "doc": "Individual Project 2",
    "title": "Getting started with this assignment",
    "content": "Start by downloading the starter code. Extract the archive and run npm install to fetch the dependencies. Installation notes . Configuring Jest and VSCode: If you would like to use the built-in Jest test runner for VSCode (where it shows the tests and their status in the sidebar), the easiest way to accomplish this for this project is to open just the “frontend” directory or just the “townService” directory in VSCode - not the top-level “ip2-handout” directory. If you have a quick-fix to make it work with the whole project at once, please feel free to share on Piazza and we will incorportate that here. NPM install failures: The libraries used for React require some native binaries to be installed – code written and compiled for your computer (not JavaScript). If you run into issues with npm install not succeeding, please try installing the following libraries using either Homebrew (if on Mac), apt-get, or your favorite other package manager: pixman, cairo, pkgconfig and pango. For example, run brew install pixman cairo pkgconfig pango. If you are on a newer Mac with an M1 or M2 chip, you may need to use arch -arm64 brew install pixman cairo pango. On Windows: Students have reported seeing the failure error /bin/bash: node: command not found upon npm install in the frontend directory. If you encounter this error, please try to delete the node_modules directory and re-run npm install in the frontend directory from a bash shell instead of a windows command prompt. Changelog: . | 9/26: Update description for socket.on('interactableUpdate') on this page to match the handout; update the handout to remove prettier/linting issues (if you already have downloaded the handout, npm run format in the frontend directory will get you the same thing) | 9/27: Clarify that socket.on('interactableUpdate') should forward the interactableUpdate message to the other players in the town using the emitter newPlayer.townEmitter. Update handout so that ViewingAreaController getter for video return type is string | undefined. Add installation suggestions. | 9/29: Added sequence diagram of hook that uses town events. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2#getting-started-with-this-assignment",
    "relUrl": "/assignments/ip2#getting-started-with-this-assignment"
  },"29": {
    "doc": "Individual Project 2",
    "title": "Grading",
    "content": "This submission will be scored out of 200 points, 180 of which will be automatically awarded by the grading script, with the remaining 20 manually awarded by the course staff. Your code will automatically be evaluated for linter errors and warnings. Submissions that have any linter errors will automatically receive a grade of 0. Do not wait to run the linter until the last minute. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. Your code will be automatically evaluated for functional correctness by a test suite that expands on the core tests that are distributed in the handout. Your tests will be automatically evaluated for functional correctness by a process that will inject bugs into our reference solution: to receive full marks your tests must detect a minimum number of injected bugs. You will not receive detailed feedback on which injected bugs you do or do not find. The autograding script will impose a strict rate limit of 5 submissions per 24 hours. Submissions that fail to grade will not count against the quota. This limit exists to encourage you to start early on this assignment: students generally report that assignments like this take between 10-36 hours. If you start early, you will be able to take full advantage of the resources that we provide to help you succeed: office hours, discussion on Piazza — and the ability to have a greater total number of submission attempts. Your code will be manually evaluated for conformance to our course style guide. This manual evaluation will account for 10% of your total grade on this assignment. We will manually evaluate your code for style on the following rubric: . To receive all 20 points: . | All new names (e.g. for local variables, methods, and properties) follow the naming conventions defined in our style guide | There are no unused local variables | All public properties and methods (other than getters, setters, and constructors) are documented with JSDoc-style comments that describes what the property/method does, as defined in our style guide | The code and tests that you write generally follows the design principles discussed in week one. In particular, your design does not have duplicated code that could have been refactored into a shared method. | . We will review your code and note each violation of this rubric. We will deduct four points for each violation, up to a maximum of deducting all 20 style points. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2#grading",
    "relUrl": "/assignments/ip2#grading"
  },"30": {
    "doc": "Individual Project 2",
    "title": "Implementation Tasks",
    "content": "This deliverable has four parts; each part will be graded on its own rubric. You should complete the assignment one part at a time, in the order presented here: . Task 1: Implement Backend Handlers (15 points total) . In your last deliverable for the indivdiual project, you implemented a considerable portion of the backend code to support Interactables. What remains are the public-facing web service APIs that the client can directly invoke. These methods are located in two files: . | townService/src/town/Town.ts (socket.on('interactableUpdate') handler and addViewingArea) | townService/src/town/TownsController.ts (createViewingArea) | . The socket.on handler is automatically invoked by the socket-io library when an event is received from a remote client. The createViewingArea function is automatically invoked by the tsoa REST middleware when a REST request is made by a remote client. We will learn more about both technologies in modules 9 and 10; for the purposes of this assignment you need only implement the functions as specified (such that they pass the provided test cases). To run the tests for this part, run the command npm test TestName in the townService directory, where TestName is either Town.test or TownsController. Clarification (9/24): A viewing area is “active” if there is a video set. View the specification for these tasks //townService/src/town/Town.ts /** * Creates a new viewing area in this town if there is not currently an active * viewing area with the same ID. The viewing area ID must match the name of a * viewing area that exists in this town's map, and the viewing area must not * already have a video set. * * If successful creating the viewing area, this method: * Adds any players who are in the region defined by the viewing area to it * Notifies all players in the town that the viewing area has been updated by * emitting an interactableUpdate event * * @param viewingArea Information describing the viewing area to create. * * @returns True if the viewing area was created or false if there is no known * viewing area with the specified ID or if there is already an active viewing area * with the specified ID or if there is no video URL specified */ public addViewingArea(viewingArea: ViewingAreaModel): boolean // townService/src/town/TownsController.ts /** * Creates a viewing area in a given town * * @param townID ID of the town in which to create the new viewing area * @param sessionToken session token of the player making the request, must * match the session token returned when the player joined the town * @param requestBody The new viewing area to create * * @throws InvalidParametersError if the session token is not valid, or if the * viewing area could not be created */ @Post('{townID}/viewingArea') @Response&lt;InvalidParametersError&gt;(400, 'Invalid values specified') public async createViewingArea( @Path() townID: string, @Header('X-Session-Token') sessionToken: string, @Body() requestBody: ViewingArea, ): Promise&lt;void&gt; // townService/src/town/Town.ts // Set up a listener to process updates to interactables. // Currently only knows how to process updates for ViewingArea's, and // ignores any other updates for any other kind of interactable. // For ViewingArea's: Uses the 'newPlayer' object's 'towmEmitter' to forward // the interactableUpdate to the other players in the town. Also dispatches an // updateModel call to the viewingArea that corresponds to the interactable being // updated. Does not throw an error if the specified viewing area does not exist. socket.on('interactableUpdate', (update: Interactable) =&gt; {}); . Grading for Task 1: . You do not need to write any tests for task 1. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement Town.ts socket.on(‘interactableUpdate’): 5 points | Implement Town.ts addViewingArea: 5 points | Implement TownController.ts createViewingArea: 5 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Task 2: Implement and Test Frontend Controllers (65 points total) . Similar to the organization of the backend townService, the frontend application also has controllers that maintain the state of each interactable. The relevant files for this task are located in the directory frontend/src/classes/. The TownController interacts with the townService, receiving ServerToClientEvents from the backend and emitting ClientToServerEvents to the backend. The TownController, in turn, emits TownEvents to components in the frontend. These events are the events that the GUI components will observe. Each Viewing Area is represented by a ViewingAreaController, which emits ViewingAreaEvents. Each Conversation Area is represented by a ConversationAreaController, which emits ConversationAreaEvents. GUI components that display details about each converation area or viewing area will subscribe to these events so that they can remain up-to-date with the current state of the interactable. Your next task is to implement the ViewingAreaController and ConversationAreaController, along with the event handler for TownController to receive interactableUpdate messages from the townService. Each of these classes are stubbed out in the handout. Our handout does not include all of the tests in ViewingAreaController.test.ts or ConversationAreaController.test.ts. To receive full marks on task 2, you will also need enhance these test suites to check all of the behaviors of the methods that you are implementing. Testing the behavior of the ViewingAreaController and ConversationAreaController will require you to use mocks. The ViewingAreaController.test.ts and ConversationAreaController.test.ts files in the handout contain all of the setup code that you will need to write tests to check that the correct listeners are invoked. The mockListeners object (in each test) are mock objects, which do not provide any implementation of the listener callbacks, but keep track of when they have been called. In this way, you can write an assertion that some listener method is called by asserting that the mock listener was called. To write an assertion that, for example, the occupantsChange listener is invoked in ConversationAreaController, you could use Jest’s toHaveBeenCalled() matcher, as in: expect(mockListeners.occupantsChange).toHaveBeenCalled(). You might also find it useful to use the toHaveBeenCalledWith(args..) matcher to check the arguments that are passed to the listener. To assert that a listener was not called, chain the not matcher, as in expect(...).not.toHaveBeenCalled(). We strongly suggest writing the tests before (or concurrent) with implementing the classes, so that you can use your own tests to help you develop your implementation. Note: you may find it useful to use the helper methods isConversationArea and isViewingArea, defined in TypeUtils.ts . To run the tests for this part, run the command npm test TestName in the frontend directory, where TestName is either ViewingAreaController, ConversationAreaController, or TownController. View the specification for these tasks ConversationAreaController: . /** * Create a new ConversationAreaController * @param id * @param topic */ constructor(id: string, topic?: string) { super(); this._id = id; this._topic = topic; } /** * The ID of this conversation area (read only) */ get id() /** * The list of occupants in this conversation area. Changing the set of occupants * will emit an occupantsChange event. */ set occupants(newOccupants: PlayerController[]) get occupants() /** * The topic of the conversation area. Changing the topic will emit a topicChange event * * Setting the topic to the value `undefined` will indicate that the conversation area is not active */ set topic(newTopic: string | undefined) get topic(): string | undefined /** * A conversation area is empty if there are no occupants in it, or the topic is undefined. */ isEmpty(): boolean /** * Return a representation of this ConversationAreaController that matches the * townService's representation and is suitable for transmitting over the network. */ toConversationAreaModel(): ConversationAreaModel . ViewingAreaController . /** * Constructs a new ViewingAreaController, initialized with the state of the * provided viewingAreaModel. * * @param viewingAreaModel The viewing area model that this controller should represent */ constructor(viewingAreaModel: ViewingAreaModel) /** * The ID of the viewing area represented by this viewing area controller * This property is read-only: once a ViewingAreaController is created, it will always be * tied to the same viewing area ID. */ public get id() /** * The URL of the video assigned to this viewing area, or undefined if there is not one. */ public get video() /** * The URL of the video assigned to this viewing area, or undefined if there is not one. * * Changing this value will emit a 'videoChange' event to listeners */ public set video(video: string | undefined) /** * The playback position of the video, in seconds (a floating point number) */ public get elapsedTimeSec() /** * The playback position of the video, in seconds (a floating point number) * * Changing this value will emit a 'progressChange' event to listeners */ public set elapsedTimeSec(elapsedTimeSec: number) /** * The playback state - true indicating that the video is playing, false indicating * that the video is paused. */ public get isPlaying() /** * The playback state - true indicating that the video is playing, false indicating * that the video is paused. * * Changing this value will emit a 'playbackChange' event to listeners */ public set isPlaying(isPlaying: boolean) /** * @returns ViewingAreaModel that represents the current state of this ViewingAreaController */ public viewingAreaModel(): ViewingAreaModel . TownController socket.on('interactableUpdate') . /** * When an interactable's state changes, push that update into the relevant controller, which is assumed * to be either a Viewing Area or a Conversation Area, and which is assumed to already be represented by a * ViewingAreaController or ConversationAreaController that this TownController has. * * If a conversation area transitions from empty to occupied (or occupied to empty), this handler will emit * a conversationAreasChagned event to listeners of this TownController. * * If the update changes properties of the interactable, the interactable is also expected to emit its own * events (@see ViewingAreaController and @see ConversationAreaController) */ this._socket.on('interactableUpdate', interactable =&gt; {}) . Grading for Task 2: . Point break down for each of the implementation tasks: . | Implement ConversationAreaController: 7 points | Implement ViewingAreaController: 7 points | Implement TownController.interactableUpdate: 6 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Point break down for each of the testing tasks: . | Test ConversationAreaController occupants property: 7 points | Test ConversationAreaController topic property: 7 points | Test ConversationAreaController isEmpty: 7 points | Test ConversationAreaController toConversationAreaModel: 2 points | Test ViewingAreaController video property: 7 points | Test ViewingAreaController elapsedTimeSec property: 7 points | Test ViewingAreaController isPlaying property: 7 points | Test ViewingAreaController viewingAreaModel: 1 points | . Partial marks are available for detecting some (but not all) faults. The number of faults detected may not directly correlate with the difficulty of writing the test: there are several faults that are nearly guaranteed to be detected together (writing a test that finds one of them is guaranteed to find both of them), which is why there are different cutoffs for partial and full marks for the tests. Task 3: Implement React Hooks (60 points total) . As discussed in Module 8, an effective pattern for building React applications is to use hooks within components to access global state. As part of the refactoring to implement the Interactable abstraction throughout Covey.Town, Avery also refactored the entire React-based frontend to use this pattern of hooks. Before implementing the final component that displays and synchronizes video playback in Viewing Areas, your next task will be to implement these hooks - some of which are related to the interactables, and some of which are related to Avery’s overall refactoring to use more hooks. Some of these hooks may require you to include useEffect and/or useState hooks within the hook that you are building. For each of the hooks, consider the events that they might need to listen to (i.e. TownEvents for the hooks that monitor a TownController and ConversationAreaEvents for those that monitor a ConversationAreaController). Hooks that need to monitor TownController events may require you to use our own useTownController() hook, which returns the current TownController. The sequence diagram below shows the expected interactions between hooks that subscribe to TownEvents, indicating the interfaces that the hook uses: . Be sure to follow the rules of hooks when implementing your hooks - these will be enforced by the linter, and also by the TAs when grading for style. To run the tests for this part, run the command npm test hooks in the frontend directory. View the specification for the hooks In frontend/src/classes/TownController.ts . /** * A react hook to retrieve the settings for this town * * This hook will cause components that use it to re-render when the settings change. * * This hook relies on the TownControllerContext. * @returns an object with the properties \"friendlyName\" and \"isPubliclyListed\", * representing the current settings of the current town */ export function useTownSettings() /** * A react hook to retrieve the active conversation areas. This hook will re-render any components * that use it when the set of conversation areas changes. It does *not* re-render its dependent components * when the state of one of those areas changes - if that is desired, @see useConversationAreaTopic and @see useConversationAreaOccupants * * This hook relies on the TownControllerContext. * * @returns the list of conversation area controllers that are currently \"active\" */ export function useActiveConversationAreas(): ConversationAreaController[] /** * A react hook to return the PlayerController's corresponding to each player in the town. * * This hook will cause components that use it to re-render when the set of players in the town changes. * * This hook will *not* trigger re-renders if a player moves. * * This hook relies on the TownControllerContext. * * @returns an array of PlayerController's, representing the current set of players in the town */ export function usePlayers(): PlayerController[] . In frontend/src/classes/ConversationAreaController.ts: . /** * A react hook to retrieve the occupants of a ConversationAreaController, returning an array of PlayerController. * * This hook will re-render any components that use it when the set of occupants changes. */ export function useConversationAreaOccupants(area: ConversationAreaController): PlayerController[] /** * A react hook to retrieve the topic of a ConversationAreaController. * If there is currently no topic defined, it will return NO_TOPIC_STRING. * * This hook will re-render any components that use it when the topic changes. */ export function useConversationAreaTopic(area: ConversationAreaController): string . There are no hooks for the ViewingAreaController at this point - Avery noticed that the data in the ViewingAreaController is only used by at most one component, so felt that it would be an over-eager design optimization to define reusable hooks to access that data now. Grading for Task 3: . You do not need to write any tests for task 1. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement TownController.ts useTownSettings: 12 points | Implement TownController.ts useActiveConversationAreas: 12 points | Implement TownController.ts usePlayers: 12 points | Implement ConversationAreaController.ts useConversationAreaOccupants: 12 points | Implement ConversationAreaController.ts useConversationAreaTopic: 12 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. Task 4: GUI Component for Viewing Area Videos (40 points) . With the controllers implemented, the last task will be to implement the frontend GUI component to play back videos in a Viewing Area. Avery has implemented the skeleton for this component, which also includes a form to set the video for a viewing area if it hasn’t already been set. Your task is to implement the component ViewingAreaVideo, which renders the viewing area’s video and synchronizes playback with the ViewingAreaController. You will find that there is already a skeleton of this component created, which renders a &lt;ReactPlayer&gt; component inside of a &lt;Container&gt;, along with the ID of the ViewingArea. In addition to useState and useEffect, this component will also need to make use of React’s useRef hook. useRef is used to make a reference to a child component - the React documentation shows how useRef is used to make a reference to a text input that can be used from within an event handler. The handout code contains the declaration of a useRef hook and ties that reference to the ReactPlayer component. You will find it necessary to reference the ReactPlayer component in order to retrieve its current playback timecode, and to seek to a new timecode. To run the tests for this part, run the command npm test ViewingAreaVideo in the frontend directory. The specification for this component is provided in comments in the file frontend/src/components/Town/interactables/ViewingAreaVideo.tsx, and reproduced below: . View the specification for this component /** * The ViewingAreaVideo component renders a ViewingArea's video, using the ReactPlayer component. * The URL property of the ReactPlayer is set to the ViewingAreaController's video property, and the isPlaying * property is set, by default, to the controller's isPlaying property. * * The ViewingAreaVideo subscribes to the ViewingAreaController's events, and responds to * playbackChange events by pausing (or resuming) the video playback as appropriate. In response to * progressChange events, the ViewingAreaVideo component will seek the video playback to the same timecode. * To avoid jittering, the playback is allowed to drift by up to ALLOWED_DRIFT before seeking: the video should * not be seek'ed to the newTime from a progressChange event unless the difference between the current time of * the video playback exceeds ALLOWED_DRIFT. * * The ViewingAreaVideo also subscribes to onProgress, onPause, onPlay, and onEnded events of the ReactPlayer. * In response to these events, the ViewingAreaVideo updates the ViewingAreaController's properties, and * uses the TownController to emit a viewing area update. * * @param props: A single property 'controller', which is the ViewingAreaController corresponding to the * current viewing area. */ export function ViewingAreaVideo({ controller, }: { controller: ViewingAreaController; }): JSX.Element . Hints: The playing property of the ReactPlayer will need to be changed during the component’s lifetime: set to false when another player pauses the video, or true when it is resumed. This might be a good use-case for useState. In contrast, seeking the video to a new timecode is accomplished not by changing a property, but by using the instance method seekTo of the ReactPlayer. The handout code already has a useRef() hook to demonstrate how to get a reference to the component. Grading for Task 4: . You do not need to write any tests for task 4. The handout contains all of the tests that our grading script will use. Point break down for each of the implementation tasks: . | Implement ViewingAreaVideo - Set properties of the ReactPlayer: 6 points | Implement ViewingAreaVideo - Bridging events from the ViewingAreaController to the ReactPlayer: 17 points | Implement ViewingAreaVideo - Bridging events from the ReactPlayer to the ViewingAreaController: 17 points | . To receive marks for implementing each feature, your implementation must pass all of our tests for it. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2#implementation-tasks",
    "relUrl": "/assignments/ip2#implementation-tasks"
  },"31": {
    "doc": "Individual Project 2",
    "title": "Submission Instructions",
    "content": "Submit your assignment in GradeScope. The easiest way to get into GradeScope the first time is to first sign into Canvas and then click the link on our course for “GradeScope”. You should then also have the option to create an account on GradeScope (if you don’t already have one) so that you can log in to GradeScope directly. Please contact the instructors immediately if you have difficulty accessing the course on GradeScope. To submit your assignment: run the command npm run zip in the top-level directory of the handout. This will produce a file called covey-town.zip which should contain these files: . | townService/src/town/Town.ts | townService/src/town/TownsController.ts | frontend/src/classes/TownController.ts | frontend/src/classes/ConversationAreaController.ts | frontend/src/classes/ConversationAreaController.test.ts | frontend/src/classes/ViewingAreaController.ts | frontend/src/classes/ViewingAreaController.test.ts | frontend/src/components/Town/interactables/ViewingAreaVideo.tsx | . GradeScope will provide you with feedback on your submission, but note that it will not include any marks that will be assigned after we manually grade your submission for code style (it will show 0 for this until it is graded). It may take several minutes for the grading script to complete. GradeScope is configured to only provide feedback on at most 5 submissions per-24-hours per-student (submissions that fail to run or receive a grade of 0 are not counted in that limit). We strongly encourage you to lint and test your submission on your local development machine, and not rely on GradeScope for providing grading feedback - relying on GradeScope is a very slow feedback loop. To check for linter errors, run the command npm run lint from the terminal. The handout contains the same eslint configuration that is used by our grading script. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2#submission-instructions",
    "relUrl": "/assignments/ip2#submission-instructions"
  },"32": {
    "doc": "Individual Project 2",
    "title": "Individual Project 2",
    "content": "Welcome back! We were pleased to see your thorough implementation of the new Interactables abstraction in the townService of Covey.Town. While you have been working on these backend features, our UX designer Calin has finished the design of the ViewingAreas feature, and we’re now ready to give you the rest of the feature. Calin found the react-player component, which seems to be a great component to use to implement video playback within Covey.Town. In this (final) deliverable for the ViewingAreas feature, you will create the following components: . | Within the backend townService: REST and socket-io endpoints to process API calls from clients, dispatching them to the controllers delivered in IP1. | Within the frontend application: . | An event handler for the frontend TownController to process interactableUpdate messages dispatched by the townService (you implemented those backend components in IP1). | A ViewingAreaController and ConversationAreaController that will maintain data structures and dispatch events to the UI in response to updates from the TownController | React hooks to update existing React components in response to changes to ViewingAreas, ConversationAreas, and town settings | A React component for the ViewingArea that integrates the react-player with those hooks and controllers | . | . When you complete this deliverable, you should have a fully-functioning implementation of the Viewing Area feature, and a better understanding of the covey.town architecture. This sequence diagram shows the interaction between these high level components to create a new viewing area and play a video back synchronized between multiple frontends. The sequence beings when a user selects a video to play in a viewing area, entering it into the ViewingAreaVideo: . | The ViewingAreaVideo asks the TownController to create a new viewing area with the specified video | The TownController asks the townService to create the new viewing area with the specified video, making a REST call | Assuming that the request was valid, the townService returns success | Assuming that the request was valid, the TownController returns success | The townService broadcasts an interactableUpdate message with the new video URL (happening in parallel with 9) | The TownController receives the interactableUpdate, finds the correct ViewingAreaController and pushes an updateModel event to it | The ViewingAreaController updates its model, and emits a videoChange event to its listeners | The ViewingAreaVideo receives the update, re-renders, and now plays the video | The townService sends the same interactableUpdate to Calin’s frontend, and (6-8) happen in Calin’s frontend | During playback, Avery’s ViewingAreaVideo updates the elapsedTimeSec on the ViewingAreaController | In response to the update from the ViewingAreaVideo, the ViewingAreaController asks the TownController to emit an update to the townService | The TownController emits the interactableUpdate event, notifying the backend of the elapsed playack time | The townService relays that interactableUpdate to other clients, which will ensure that their video playback is synchronized | In parallel to 10-13, Calin’s client emits interactableUpdate updates with their elapsedTimeSec | The townService forwards this update to Avery’s frontend TownController | Avery’s TownController finds the ViewingAreaController responsible for that viewing area, and calls its updateModel method, updating its view of the elapsedTimeSec | The ViewingAreaController emits a progressChange event to its listeners. | The ViewingAreaVideo will seek to the new elapsedTimeSec if it is out of sync | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/ip2",
    "relUrl": "/assignments/ip2"
  },"33": {
    "doc": "1 - Orientation & Requirements",
    "title": "1 - Orientation & Requirements",
    "content": "Learning Objectives: . In this lecture, you will learn . | a little about the scope of Software Engineering and how it differs from programming | how this course will be organized, and what will be expected from you each week. | two different ways to solicit and document our users’ requirements | . Important Dates: . | Individual Project Deliverable 1 Due Sep 21 by 11am | . Lecture Slides: . | Course Introduction Slides PDF, PPT | Requirements Gathering Slides PDF, PPT | . Tutorials . | Getting Started with TypeScript | . Resources . | Class Syllabus | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/1-requirements-testing",
    "relUrl": "/modules/1-requirements-testing"
  },"34": {
    "doc": "10 - Distributed Systems Architectures",
    "title": "10 - Distributed Systems Architectures",
    "content": "Learning Objectives: . In this module, you will learn to: . | Recognize common software architectures | Understand tradeoffs of scalability, performance, and fault tolerance between these architectures | Describe what makes web services RESTful, and implement a REST API | . Lecture Slides: . | Distributed Systems Architectures Slides PDF, PPT | . Activity . | Activity: Transcript REST Server | . Resources . | Online book chapter: “Thinking Like a Software Architect” by Christian Kästner | Podcast: “Chris Richardson on Microservice Patterns” - SE Radio | Counterpoint podcast: “Roberta Arcoverde on Stack Overflow’s Monolith” | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/10-distributed-architectures",
    "relUrl": "/modules/10-distributed-architectures"
  },"35": {
    "doc": "11 - Test Adequacy",
    "title": "11 - Test Adequacy",
    "content": "Learning Objectives: . In this module, you will learn to: . | Explain what makes a good test, and give examples and counter examples | Explain different things a test suite might accomplish, and sketch how one might judge how well a test suite accomplishes those goals | . Lecture Slides: . | What makes a good test suite? Slides PDF, PPT | . Activity . | Activity: Transcript Server Test Adequacy | . Resources . | Software Engineering at Google: “Testing” | Are mutants a valid substitute for real faults in software testing? | StrykerJS - Mutation Testing Tool | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/11-good-tests",
    "relUrl": "/modules/11-good-tests"
  },"36": {
    "doc": "12 - Larger Tests",
    "title": "12 - Larger Tests",
    "content": "Learning Objectives: . In this module, you will learn to: . | Explain why you might need a “test double“ in your testing | Understand how and when to apply different kinds of test “doubles” such as “mocks and spies” | . Lecture Slides: . | Designing Tests for Large Systems Slides PDF, PPT | . Resources . | Software Engineering at Google: “Larger Testing” | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/12-larger-tests",
    "relUrl": "/modules/12-larger-tests"
  },"37": {
    "doc": "13 - Cloud Infrastructure",
    "title": "13 - Cloud Infrastructure",
    "content": "Learning Objectives: . In this module, you will learn to: . | Describe what “cloud” computing is | Understand the role of virtual machines and containers in cloud computing | Deploy a web app to the cloud | . Lecture Slides: . | Cloud Infrastructure Slides PDF, PPT | . Activity . | Activity: Transcript Server Heroku Deployment | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/13-cloud-infrastructure",
    "relUrl": "/modules/13-cloud-infrastructure"
  },"38": {
    "doc": "14 - Continuous Development",
    "title": "14 - Continuous Development",
    "content": "Learning Objectives: . In this module, you will learn to: . | Describe how continuous integration helps to catch errors sooner in the software lifecycle (“moving to the left”) | Describe the benefits of a culture of code review | Describe strategies for performing quality-assurance on software as and after it is delivered | . Lecture Slides: . | Continuous Development Slides PDF, PPT | . Resources . | “Expectations, Outcomes, and Challenges of Modern Code Review”, Christian Bird and Alberto Baccheli | “Modern Code Review: A Case Study at Google”, Caitlin Sadowski et al | Podcast Michaela Greiler on Code Reviews, with Felienne Hermans, 2020 | Software Engineering at Google especially the following chapters . | Chapter 9: Code Review | Chapter 16: Version Control and Branch Management | Chapter 19: Critique: Google’s Code Review Tool | Chapter 23: Continuous Integration | Chapter 24: Continuous Delivery | . | “Case Study 4: The $440 Million Software Error at Knight Capital”, Henrico Dolfing | “Rapid release at massive scale” by Chuck Rossi | “Continuous Deployment of Mobile Software at Facebook”, Chuck Rossi et al | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/14-continuous-development",
    "relUrl": "/modules/14-continuous-development"
  },"39": {
    "doc": "15 - Security",
    "title": "15 - Security",
    "content": "Learning Objectives: . In this module, you will learn to: . | Describe that security is a spectrum, and be able to define a realistic threat model for a given system | Evaluate the tradeoffs between security and costs in software engineering | Recognize the causes of and common mitigations for common vulnerabilities in web applications | Utilize static analysis tools to identify common weaknesses in code | . Lecture Slides: . | Software Engineering and Security Slides PDF, PPT | . For Further Reading . | XSS on transcript server | “What are Weak Links in the npm Supply Chain?” | “Why secret detection tools are not enough: It’s not just about false positives - An industrial case study” | “A comparative study of vulnerability reporting by software composition analysis tools” | “Practical Automated Detection of Malicious npm Packages” | HashiCorp Vault | “OWASP Top 10 Web Security Risks” | Software supply-chain vulnerabilities: ESLint 2018 attack, Podcast on SolarWinds attack | Security awareness/training activity: OWASP Juice Shop, online demo | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/15-security",
    "relUrl": "/modules/15-security"
  },"40": {
    "doc": "16 - Technical Debt",
    "title": "16 - Technical Debt",
    "content": "Learning Objectives: . In this module, you will learn to: . | “Refactoring”: restructuring of code to improve structure . | Some common code examples for “smells” (anti-patterns). | “Technical Debt”: generalization covering all internal problems in a codebase | . Lecture Slides: . | Technical Debt Slides PDF, PPT | . Resources . | Book: Refactoring: Improving the design of existing code | Book: Managing Technical Debt: Reducing Friction in Software Development | Software Engineering at Google - Chapter 15 (Deprecation) | Technical Debt: From Metaphor to Theory and Practice (IEEE Software artice from 2012) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/16-technical-debt",
    "relUrl": "/modules/16-technical-debt"
  },"41": {
    "doc": "17 - Open Source",
    "title": "17 - Open Source",
    "content": "Learning Objectives: . In this module, you will learn to: . | Understand the terminology “free software” and explain open source culture and principles. | Express an educated opinion on the philosophical/political debate between open source and proprietary principles. | Reason about the tradeoffs of different open source licenses and business model | . Lecture Slides: . | Open Source Slides PDF, PPT | . Resources . | Open Sources: Voices from the Open Source Revolution | Why Open Source Misses the Point of Free Software | How Open Source Ate Software: Understand the Open Source Movement and So Much More | MongoDB Licensing FAQ | MongoDB Removed from Debian due to incompatible liense | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/17-open-source",
    "relUrl": "/modules/17-open-source"
  },"42": {
    "doc": "18 - Ethics",
    "title": "18 - Ethics",
    "content": "Learning Objectives: . In this week of the course, you will learn about ethical problems in Software Engineering. You will learn about some of the many unintended consequences of the software we build, and about ways to analyze the ethical problems that are associated with that software . Lecture Slides: . | Ethics Slides PDF, PPT | . Resources . | Software Engineering @ Google, Chapter 4 (Engineering for Equity) | Coverage of Google Photos auto-tagging bug WSJ, and more recent from Wired | COMPAS coverage: The Atlantic, ProPublica, ProPublica data | Price discrimination: WSJ, FairTest | Climate considerations: in NLP, in content delivery networks | Robles v Domino’s Pizza coverage: Eater, Columbia Journal of Law &amp; Social Problems | Citicorp Center Design case study | Therac-25 case study | Value Sensitive Design @ Khoury | ACM software engineering code of ethics, IEEE code of ethics | Web accessibility resources from W3C: WCAG 2.0 specification, evaluating web accessibility | On the origins of the ADA: Judy Heumann memoir, Crip Camp: A Disability Revolution (Netflix) | Podcast: Margaret Burnett on Gender, Cognitive Styles, and Usability Bugs | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/18-equitable-software",
    "relUrl": "/modules/18-equitable-software"
  },"43": {
    "doc": "2 - From Requirements to Code",
    "title": "2 - From Requirements to Code",
    "content": "Learning Objectives: . In this lecture, you will learn to: . | Explain the basics of the Test-Driven Design | Develop simple applications using Typescript and Jest | Learn more about Typescript and Jest from tutorials, blog posts, and documentation | . Important Dates: . | Individual Project Deliverable 1 Due Sep 21 by 11am | . Lecture Slides: . | From Requirements to Code Slides PDF, PPT | . Other resources . | TDD Activity Handout | . Tutorials . | Writing Tests with Jest | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/2-requirements-to-code",
    "relUrl": "/modules/2-requirements-to-code"
  },"44": {
    "doc": "3 - Code-Level Design Principles",
    "title": "3 - Code-Level Design Principles",
    "content": "Learning Objectives: . This lecture is about writing code that other people will be able to understand, reuse, and modify. We’ve distilled this down to five general program-design princples. By the end of this lesson you should be able to: . | Describe the purpose of our design principles | List 5 code-level design principles with examples | Identify some violations of the principles and suggest ways to mitigate them | . Important Dates: . | Individual Project Deliverable 1 Due Sep 21 by 11am | . Lecture Slides: . | General Program Design Principles Slides PDF, PPT | . Activities: . | Traffic Light Activity | . Resources . | Code Examples from Lecture (zip file) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/3-code-level-design-principles",
    "relUrl": "/modules/3-code-level-design-principles"
  },"45": {
    "doc": "4 - Interaction-Level Design Patterns",
    "title": "4 - Interaction-Level Design Patterns",
    "content": "Learning Objectives: . This lecture is about common patterns for organizing the communication between classes. These are what are often called “OO Design Patterns”. We will see that using such patterns makes OO code more readable and modifiable. By the end of this lesson, you should be able to . | Explain how patterns capture common solutions and tradeoffs for recurring problems. | Give 4 examples of interaction patterns and describe their distinguishing characteristics | Draw a picture or give an example to illustrate each one | . Important Dates: . | Individual Project Deliverable 1 Due Sep 21 by 11am | . Lecture Slides: . | Interaction-Level Design Patterns Slides PDF, PPT | . Activities: . | Weather Station Activity (zip file) (README) | . Resources . | Code Examples from Lecture (zip file) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/4-interaction-level-design-patterns",
    "relUrl": "/modules/4-interaction-level-design-patterns"
  },"46": {
    "doc": "5 - Concurrency Patterns in Typescript",
    "title": "5 - Concurrency Patterns in Typescript",
    "content": "Learning Objectives: . 1 GHz CPU executes an instruction every 1 ns. Almost anything else takes approximately forever. Rather than waste time waiting for a long-running operation to complete, we want our programs to make progress on other tasks. This is called “masking latency with concurrency”. In this lecture, we will study some common patterns for organizing concurrency in Typescript/Javascript. By the end of this lesson, you should be prepared to: . | Explain how to achieve concurrency through asynchronous operations and Promise.all in TypeScript. | Write asynchronous and concurrent code in TypeScript using async/await and Promise.all. | . Important Dates: . | Individual Project Deliverable 1 Due Sep 21 by 11am | . Lecture Slides: . | Concurrency Patterns in Typescript Slides PDF, PPT | . Activities: . | Async Activity (zip file) | . Resources . | Code Examples from Slides (zip file) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/5-concurrency-patterns-in-typescript",
    "relUrl": "/modules/5-concurrency-patterns-in-typescript"
  },"47": {
    "doc": "6 - Software Process",
    "title": "6 - Software Process",
    "content": "Learning Objectives: . The overall theme of this week’s lessons is software engineering processes: how do we organize our (non-programming) activities so that we can build some software project as efficiently as possible? The lessons will center on these three themes: . | How do we organize our development activities? | How do we estimate how long a software project will take? | How do we build an effective team? | . Important Dates: . | Team Formation Due Sep 28 by 1159pm | . Lecture Slides: . | Software Process Slides PDF, PPT | Agile Planning and Estimation Slides PDF, PPT | Teams Slides PDF, PPT | . Additional Readings: . The following books provide additional depth on the topics in this week’s lessons: . | The Mythical Man-Month | Head First Agile | eXtreme Programming eXplained | Debugging Teams | . For more reflections on software processes in the 1980’s, David Parnas’ article: “Software Aspects of Strategic Defense Systems”. For a discussion of various xDD approaches, see Rebecca Wirfs-Brock on What Drives Design?. Chuck Rossi’s 2014 Release Engineering Keynote includes some great discussion of Facebook’s mobile release process, now outdated, but quite interesting; there is a discussion of team structure around 18 minutes in. Sarah Mei’s 2018 Power of Agile talk provides a great discussion of embracing agile values that work for your team, while leaving behind toxic practices. Miscellaneous: Investigating the origins of the tire swing meme . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/6-software-process",
    "relUrl": "/modules/6-software-process"
  },"48": {
    "doc": "7 - React",
    "title": "7 - React",
    "content": "Learning Objectives: . This module will provide an introduction to UI development using React. By the end of this module you should be able to: . | Understand how the React framework binds data (and changes to it) to a UI | Create simple React components that use state and properties | Be able to map the three core steps of a test (construct, act, check) to UI component testing | . Lecture Slides: . | React Slides PDF, PPT | . Activities . | Activity: Building a TODO Tracker in React | . Resources . | Tutorial: Basics of React | Code examples from lecture (tgz) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/7-react",
    "relUrl": "/modules/7-react"
  },"49": {
    "doc": "8 - Patterns of React",
    "title": "8 - Patterns of React",
    "content": "Learning Objectives: . Building on Module 7, we will have a deeper discussion of common patterns of programming with React. By the end of this module you should be able to: . | Recognize and apply four common patterns in functional React components (useState, useEffect, useCustomHook, useContext) | Understand how React functional components allow behaviors to be reused | . Lecture Slides: . | Patterns of React Slides PDF, PPT | . Activity . | Activity: Transcript Client in React | . Resources . | Code examples from lecture (tgz) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/8-patterns-of-react",
    "relUrl": "/modules/8-patterns-of-react"
  },"50": {
    "doc": "9 - Distributed Systems Principles and Requirements",
    "title": "9 - Distributed Systems Principles and Requirements",
    "content": "Learning Objectives: . In this module, you will learn to: . | Describe 5 key goals of distributed systems | Understand the fundamental constraints of distributed systems | Understand the roles of replication and partitioning in the context of the DNS infrastructure | . Lecture Slides: . | Distributed Systems Principles and Requirements Slides PDF, PPT | . Resources . | “Distributed Systems for Fun and Profit” by Mikito Takada | “The CAP FAQ - The Paper Trail” | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/9-distributed-principles",
    "relUrl": "/modules/9-distributed-principles"
  },"51": {
    "doc": "Modules",
    "title": "Modules",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/modules/",
    "relUrl": "/modules/"
  },"52": {
    "doc": "Policies",
    "title": "Homework policy",
    "content": "Students must work individually on all homework assignments. We encourage you to have high-level discussions with other students in the class about the assignments, however, we require that when you turn in an assignment, it is only your work. That is, copying any part of another student’s assignment is strictly prohibited, and repercussions for doing so will be severe (up to and including failing the class outright). You are free to reuse small snippets of example code found on the Internet (e.g. via StackOverflow) provided that it is attributed. If you are concerned that by reusing and attributing that copied code it may appear that you didn’t complete the assignment yourself, then please raise a discussion with the instructor. Your work is late if it is not turned in by the deadline. | 10% will be deducted for late assignments turned in within 24 hours after the due date. | Assignments submitted more than 24 hours late will receive a zero. | . If you’re worried about being busy around the time of a HW submission, please plan ahead and get started early. Homework that does not compile or run will receive at most 50% credit. For fairness to all, there are no exceptions to the above rules. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#homework-policy",
    "relUrl": "/policies/#homework-policy"
  },"53": {
    "doc": "Policies",
    "title": "In Class Activities:",
    "content": "Most lectures will feature interactive activities and/or polls that support the material being presented. You must be present in class to participate in the activity or take the poll (participating in an online activity while not attending the synchronous session will be considered academic dishonesty and will be treated harshly). Each instructor may have a different style for assigning participation grades, but historical grading information suggests that each style results in a similar overall grade distribution. Participation grades will be posted on Canvas, and regularly updated. If you join class in person, you are strongly encouraged to bring your laptop or phone to class so that you can participate in the activities. Policy on remote attendance . If you are registered for an on-the-ground section but do not feel comfortable or are unable to attend in person, please contact your instructor in advance of class. We would like to provide the best and most comfortable learning experience, and encourage you to stay at home if advised by a medical professional. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#in-class-activities",
    "relUrl": "/policies/#in-class-activities"
  },"54": {
    "doc": "Policies",
    "title": "Grading",
    "content": "There will be an individual and a team project (in a group of 3-4). The overall grading breakdown is: . | 30% Individual project (10% for deliverable 1, 20% for deliverable 2) | 40% Team project (including peer evaluation) | 10% Participation in synchronous, in-class activities | 20% Exam | . Assignment of team project grades: In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student. We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluation {during and/or} at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Assignment of final grades: Although each instructor will use the same lesson plans and assignments, we expect that there may be variation in grades when compared between sections. Hence, each instructor will assign final grades to students in their sections, and reserve the right to apply different curves than are used by the other instructors. With each graded assignment, students will be provided with the distribution of all grades in their section. Grading grievances: If you have concerns regarding the grading of your work, please let us know right away by opening a regrade request in Gradescope. All regrade requests must be submitted within 7 days from your receipt of the graded work. If your regrade request is closed and you feel that the response was not satisfactory, you may appeal to the instructor via email within 48 hours. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#grading",
    "relUrl": "/policies/#grading"
  },"55": {
    "doc": "Policies",
    "title": "Debugging",
    "content": "One of the objectives of this class is to provide students with experiences writing new code for large, existing codebases. We anticipate that you may run into difficulties debugging the project code: it is often difficult to build debugging skills until you have a problem in front of you that requires them. The course staff is happy to help you with debugging, with the specific goal of helping you learn to successfully apply scientific debugging. Andreas Zeller’s Debugging Book provides an excellent guide to scientific debugging. The short version is roughly: if you can’t debug an issue in the first few minutes “just by looking at it”, it will be hard to keep all of the relevant information in your head at once, and a formal process to help you generate and refine guesses for why something is wrong can be immensely useful. The key idea is to create a debugging note file, where you track information like: . | What was the input/application state that caused the bug? | What was the behavior that I expected? | What was the behavior that I observed? | What are possible hypotheses for that behavior? | How have I tested those hypotheses, and what was the result? | . The overall goal with hypothesis formulation is to come up with possible causes for why the bug exists. Then, as long as those hypotheses are testable, we can prove or disprove them. Most hypotheses will be along the lines of “did I make an incorrect assumption about how a library or API works.” The devil is in enumerating all of the possible incorrect assumptions that you might have made, and testing them. The best way to attack these kinds of problems is to start with testing some high-level, general assumptions, and then refine them. If you come to us for debugging help, we will ask you to answer these 5 questions, as our goal is to help you get better at debugging and not to simply point out bugs that we might have seen before. We are happy to discuss the problematic behavior that you are observing, possible hypotheses for why that behavior is occurring, and strategies to test those hypotheses. In the past, students have found that using a variety of strategies to test their hypotheses (e.g. using a debugger, creating a minimized test case, measured application of console.log statements, internet research) are useful, and we would be happy to demonstrate these. We may not be able to stay with you while you work on refining your hypotheses and fixing the bug, but would be happy to continue following up if you get stuck again. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#debugging",
    "relUrl": "/policies/#debugging"
  },"56": {
    "doc": "Policies",
    "title": "Classroom Environment",
    "content": "To create and preserve a classroom atmosphere that optimizes teaching and learning, all participants share a responsibility in creating a civil and non-disruptive forum for the discussion of ideas. Students are expected to conduct themselves at all times in a manner that does not disrupt teaching or learning. Your comments to others should be constructive and free from harassing statements. You are encouraged to disagree with other students and the instructor, but such disagreements need to respectful and be based upon facts and documentation (rather than prejudices and personalities). The instructors reserve the right to interrupt conversations that deviate from these expectations. Repeated unprofessional or disrespectful conduct may result in a lower grade or more severe consequences. Part of the learning process in this course is respectful engagement of ideas with others. Please don’t be late. You are an essential part of the class. Your participation is an essential part of the class. If you are late, please be courteous to others when entering. BE PRESENT WHEN YOU ARE ATTENDING CLASS. Please do not distract yourself from the class by doing other activities such as phone calls, email, facebook, chat/IM/texting, games, web surfing – unless it has a direct bearing on the course. Then, by all means, surf away! . Attendance in the synchronous meetings is expected. Sometimes you cannot avoid missing a class. If you need to be away from class, it is your responsibility to catch up on the materials discussed in the class. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#classroom-environment",
    "relUrl": "/policies/#classroom-environment"
  },"57": {
    "doc": "Policies",
    "title": "Accommodations for Disabilities",
    "content": "Students who have disabilities who wish to receive academic services and/or accommodations should visit the Disability Resource Center at 20 Dodge Hall or call (617) 373-2675. Please be sure to provide your instructor with DRC’s accommodations letter early in the semester in order to avoid logistical challenges. This course includes a significant group project, and providing extensions for group work can be complex. As-per the DRC’s policy, it is the student’s responsibility to coordinate with the instructor in order to provide suitable accommodations. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#accommodations-for-disabilities",
    "relUrl": "/policies/#accommodations-for-disabilities"
  },"58": {
    "doc": "Policies",
    "title": "Title IX Notice",
    "content": "Title IX of the Education Amendments of 1972 protects individuals from sex or gender-based discrimination, including discrimination based on gender-identity, in educational programs and activities that receive federal financial assistance. Northeastern’s Title IX Policy prohibits Prohibited Offenses, which are defined as sexual harassment, sexual assault, relationship or domestic violence, and stalking. The Title IX Policy applies to the entire community, including students, faculty and staff of all gender identities. Faculty members are considered “responsible employees” at Northeastern University, meaning they are required to report all allegations of sex or gender-based discrimination to the Title IX Coordinator. If you or someone you know has been a survivor of a Prohibited Offense, confidential support and guidance can be found through University Health and Counseling Services staff and the Center for Spiritual Dialogue and Service clergy members. By law, those employees are not required to report allegations of sex or gender-based discrimination to the University. Alleged violations can be reported non-confidentially to the Title IX Coordinator within The Office for Gender Equity and Compliance at: titleix@northeastern.edu and/or through NUPD (Emergency 617.373.3333; Non-Emergency 617.373.2121). Reporting Prohibited Offenses to NUPD does NOT commit the victim/affected party to future legal action. In case of an emergency, please call 911. Please visit www.northeastern.edu/ouec for a complete list of reporting options and resources both on- and off-campus. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/#title-ix-notice",
    "relUrl": "/policies/#title-ix-notice"
  },"59": {
    "doc": "Policies",
    "title": "Policies",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/",
    "relUrl": "/policies/"
  },"60": {
    "doc": "Project Final Deliverable",
    "title": "Project: Final Deliverable Due Wednesday November 30, 11:00am EDT",
    "content": "The final project deliverable is the implementation, available in github and deployed on Netlify and Heroku, and the documentation turned in to Canvas. It also includes demos and/or posters. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable#project-final-deliverable-due-wednesday-november-30-1100am-edt",
    "relUrl": "/Assignments/project-deliverable#project-final-deliverable-due-wednesday-november-30-1100am-edt"
  },"61": {
    "doc": "Project Final Deliverable",
    "title": "Project Implementation and Documentation",
    "content": "Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Optionally, you may also open a pull request to merge your feature into our main repository (submitting a pull request, or the pull request being merged into our codebase is independent of the grade you receive, but provides a platform for more visibility of your project). ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable#project-implementation-and-documentation",
    "relUrl": "/Assignments/project-deliverable#project-implementation-and-documentation"
  },"62": {
    "doc": "Project Final Deliverable",
    "title": "Contents",
    "content": "Your final team deliverable will include: . | The implementation of your new feature, deployed to Netlify + Heroku | Automated tests for your new feature | A report that describes how to use your new feature | A poster | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any processes that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . Submission Instructions . Code and documentation . After you have pushed all of your code (and documentation) to your team’s GitHub repository, create a release on GitHub, and apply the tag version final-submission. After your release is created, you’ll find that there is now a .zip that can be downloaded from GitHub that contains a snapshot of your entire repository. Download this zip file, unpack it, and follow the instructions that you provided in your README to double-check that the course staff will be able to run your project (this step is handy to make sure that you didn’t forget to include some key files in git). If needed, you can delete the release, make some changes, and re-release up until the deadline. Submit this zip file to Canvas under the assignment “Project: Code Submission”. Submit your report separately to Canvas, under the assignment “Project: Report”. Project Poster &amp; Demo . Each team will submit a poster. Your poster will be a single-page document, that will include the following aspects: . | Short description of the project (OK to reuse text from the project plan/report) | Link to public demo site, link to source repo (OK to make the repo public now, or OK to leave as private) | Short description of the technology stack and overall design decisions | Short description of future work that could build on your project - additional features that you think could be interesting, or ideas for refactoring the code. | Screenshots of the feature, visually demonstrating the main functionality that you implemented. | . We’ve created a sample poster for the “Conversation Areas” feature, which you might find useful in deciding how to format your poster. It’s fine to use a different aspect ratio (e.g. portrait instead of landscape), and there are no specific requirements for font size or amount of text. Please try to create a document that you feel represents your project, imagine your target audience as a recruiter for a software engineering role: your goal is to demonstrate that you have some experience working on some non-trivial software engineering project. Some sections will have live (in-person) demos and others may ask you to record a demo video. Details for project demos will be provided during class by each instructor. Posters and/or demo videos (and presentations) will be submitted on Canvas, under the assignment “Project: Poster / Demo”. Individual Reflection . Create a PDF of your reflection, and submit it to Canvas, under the assignment “Project: Individual Reflection”. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable#contents",
    "relUrl": "/Assignments/project-deliverable#contents"
  },"63": {
    "doc": "Project Final Deliverable",
    "title": "Grading",
    "content": "Each project will be graded by the team’s assigned TA mentor and the instructor. We do not expect all teams to deliver all of the features that were initially proposed - in the five-week implementation period, there are sure to be some teams that encounter unexpected technical hurdles. As described in greater detail in the rubrics below, teams that have regular communication with their TA regarding their project status may be permitted variances to their project scope. For most of the submission components below, we provide two benchmark rubrics: one for a submission that is satisfactory (full marks), and one that would be meeting our minimum expectations (a pass). Rubric for remaining components will be provided by individual instructors. In practice, when grading projects we will usually assign numeric grades and provide partial credit, using these rubrics as guidelines for those two extremes. In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the marks from a student. We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each student’s self-reflection, and through each team’s (or student’s) peer evaluations during and/or at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project. Our ultimate goal is for all students to participate and receive full marks. Summary of grading . | Planning Documents . | 10% Preliminary Project Plan (already graded) | 10% Revised Project Plan (already submitted) | . | Activities During the Project . | 10% Weekly Meetings with TA Mentor and Team Surveys | 5% Ongoing development progress, including code reviews | . | Final Deliverables . | Code . | 20% Final implementation of your feature | 10% Final test suite of your feature | . | Report . | 5% Feature Overview | 10% Technical Overview | 10% Process Overview | . | 10% Demonstration &amp; Posters | . | . This adds up to 100%; this sum is worth 40% of the course grade. Here are the detailed rubrics for the final deliverables: . 20% Delivered Features . We will grade each delivered project holistically using the following two rubrics: . Satisfactory: . | Implemented feature satisfies the conditions of satisfaction as proposed by the team and as agreed to by the course staff. If technical difficulties resulted in features being dropped, the project may still earn full marks on “delivered features,” but these difficulties must have been documented with the course staff as you encountered them during development. | Implemented feature is deployed to a publicly-accessible URL, using Netlify and Heroku for hosting. Detailed instructions for deployement will be supplied later. | Implemented feature contains no ESLint warnings or errors; does not include any eslint-disable or ts-ignore flags | . Meets minimum requirements: . | Implemented feature largely satisfies acceptance criteria as proposed by the team, but may not meet the course staff’s interpretation of those criteria. | Implemented feature is deployed to a publicly-accessible URL, using Netlify and Heroku for hosting. Detailed instructions for deployement will be supplied later. | The implementation may have some obvious flaws, but largely works without crashing. | Implemented feature does not include any eslint-disable or ts-ignore flag | . 10% Testing . The project must include evidence of testing. Ideally, all new features will be accompanied by fully automated tests, but in some circumstances (particularly when engaging with Phaser, the game library, or Tiled, the map editor), this may not be feasible. If automated tests are not possible, include a discussion of your manual testing strategy, including a script that a future developer could use to manually test the feature. Satisfactory: . | Any new or modified backend features include tests that validate that the feature works as intended. These tests cover the changed code, and also contain well-written assertions that thoroughly check the expected behaviors. | Tests contains no ESLint warnings or errors; does not include any eslint-disable or ts-ignore flags | . Meets minimum requirements: . | Any new or modified backend features include at least one test, which may or may not be an effective test. | Tests may contain ESlint warnings (but no errors); does not include any eslint-disable or ts-ignore flags | . Activities During the Project . 10% Weekly Meetings with TA Mentor and Team Surveys . Throughout the semester, each team will be meeting with their TA mentor and with the instructor to discuss their project progress. Attendance at these meetings and demonstrations of progress will, cumulatively, account for 10% of the project grade. You will also be asked to complete Team Surveys and/or Peer evaluations to help track the progress. Each instructor will provide a more detailed rubric for this section of the assignment. 5% Ongoing development progress, including code reviews . Each team is expected to use their GitHub repository, regularly committing changes while developing their project. You will also be expected to use pull-requests and code reviews. Satisfactory: . | There is a clear development history visible from the git repository: features were delivered incrementally, and not in a single (or several) commits at the end of the project | There is evidence of code review - for example, pull requests that have comments on them | There is a correspondence between commit messages and the technical tasks that they are associated with; there are few (if any) commits with meaningless commits messages like . or Add files via upload. | Each team member has made at least 4 commits over the lifespan of the project | . Meets minimum requirements: . | There is a clear development history visible from the git repository: features were delivered incrementally, and not in a single (or several) commits at the end of the project | Each team member has made at least 2 commits over the lifespan of the project | . Final Report . The final report should consist of three sections: . 5% Report – Feature Overview . Satisfactory: . | The Feature section contains sufficient documentation for a user to interact with your updated version of Covey.Town. | The documentation covers all steps that the user would need to take to exercise all of your user stories. | Screenshots are included that capture the key interactions between a user and your new feature. | Course staff were able to follow these instructions to successfully interact with your project implementation. | The section is at most 4 pages (roughly 2,000 words maximum), NOT including figures. Fewer pages are absolutely acceptable, consider this a rough limit | . Meets minimum requirements: . | The Feature contains documentation for a user to interact with your updated version of Covey.Town, but perhaps does not fully describe how. | The documentation includes at least one or two screenshots, but screenshots do not capture interactions with all of the user stories. | The course staff were able to figure out how to use it through trial and error. | The section is at most 4 pages, NOT including figures. Fewer pages are absolutely acceptable, consider this a rough limit | . 10% Report - Technical Overview . Satisfactory: . | Technical Overview contains a description of any substantive changes to the existing Covey.Town codebase, and of the architecture of your new code. | It uses UML diagrams, CRC cards, state diagrams or any of the other techniques that help describe the structure. | It provides a well-reasoned rationale for why this is the “right” design. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) Meets minimum requirements: . | Technical Overview includes a description of all major changes to the code compared to our existing Covey.Town codebase. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . 10% Process Overview . Satisfactory: . | Process overview contains a detailed description of the manner in which agile project management processes were used during the project (i.e., sprints, sprint reviews, retrospectives and blameless reviews). | It provides a summary of what was planned to happen in each sprint vs what actually happened, with a discussion of what was revised as a result. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . Meets minimum requirements: . | It provides a summary of what was planned to happen in each sprint vs what actually happened, with a discussion of what was revised as a result. | The document is at most 2 pages (fewer pages are absolutely acceptable, consider this a rough limit) | . 10% Demonstration / Posters . Each team will be required to submit a poster. In addition, some sections may have a demo (live in-person, via zoom or by recorded video). Each instructor will provide details regarding expectations for the demo and/or presentation. The schedule and manner of these demos might also vary from section to section. Select projects will be hosted in our project showcase. Here are the projects from Spring 2022 project showcase. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable#grading",
    "relUrl": "/Assignments/project-deliverable#grading"
  },"64": {
    "doc": "Project Final Deliverable",
    "title": "Individual Reflection",
    "content": "Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own. Satisfactory completion of all parts of this reflection is required to receive an “A” grade in the course, and may be used to calibrate project scores across multiple team members. The individual reflection also provides an opportunity for students to provide confidential feedback on the performance of their teammates. Project Concept . Reflect on the evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph describing all variances from original project concept; | Includes at least 1 paragraph of personal reflection on the cause of any variances from the project concept. | . Project Process . Reflect on the evolution of your development process: How did the process by which you designed and implemented evolve from your original project plan? Were there any processes that in hindsight, you wish that you followed, or wish that you followed better? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph describing all variances from the software development processes envisioned in your original project plan; | Includes at least 1 paragraph describing software processes (described in class or not) that you wish you had followed, or wish you had followed better, supported by evidence from your personal experience working on the project. | . Project Team . Reflect on your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? Do you think that each of your teammates are deserving of the same grade as you? . Satisfactory: . | Is at least 2 paragraphs long; | Includes at least 1 paragraph reflecting on your own performance as a team member on this project, including what you would have done differently, given what you know now; | Includes at least 1 paragraph reflecting on your overall team dynamic, including strengths and weaknesses. Reflect on how you might have organized your team differently given what you know now. | . Change Log . | 10/26: Initial Release | 10/29: Added details about the poster | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable#individual-reflection-1",
    "relUrl": "/Assignments/project-deliverable#individual-reflection-1"
  },"65": {
    "doc": "Project Final Deliverable",
    "title": "Project Final Deliverable",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/Assignments/project-deliverable",
    "relUrl": "/Assignments/project-deliverable"
  },"66": {
    "doc": "Project Overview",
    "title": "Project Overview",
    "content": "The individual and team project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement a new feature. The codebase that we are be developing on is a remote collaboration tool called Covey.Town. Covey.Town provides a virtual meeting space where different groups of people can have simultaneous video calls, allowing participants to drift between different conversations, just like in real life. Covey.Town is inspired by existing products like Gather.Town, Sococo, and Gatherly.IO — but it is an open source effort, and the features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. Select projects from Spring 2022 are hosted in our project showcase. Overview of Project Deliverables . | Date | Deliverable | Description | . | 9/28/22 | Team Formation | Specify preferences for teammates | . | 10/12/22 | Preliminary Project Plan | Propose a new feature for Covey.Town that can be planned and implemented within 7 weeks | . | 10/26/22 | Revised Project Plan | Refine the scope of your feature based on staff feedback, define detailed requirements and project acceptance criteria. | . | 11/30/22 | Project Implementation and Documentation | Deliver your new feature, including design documentation and tests | . Summary of Project Grading . Your overall project grade (which will account for 40% of your final grade in this course) will be the weighted average of each of the deliverables. | Planning Documents . | 10% Preliminary Project Plan | 10% Revised Project Plan | . | Activities During the Project . | 10% Weekly Meetings with TA Mentor and Team Surveys | 5% Ongoing development progress, including code reviews | . | Final Deliverables . | Code . | 20% Final implementation of your feature | 10% Final test suite of your feature | . | Report . | 5% Feature Overview | 10% Technical Overview | 10% Process Overview | . | 10% Demonstration &amp; Posters | . | . In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student. We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluation (during and/or) at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Team Formation . All projects will be completed in a team of 3-4 students. The very first deliverable for the project will be a team formation survey: you will be able to indicate your preferences for teammates. The instructors will assign students to the teams based on a number of factors including your responses to the survey. All students in each team must be in the same section of the class. Team Meetings with TA Mentor . Each team will be assigned a TA to act as a mentor, who will also serve as your point of contact for project grading. During the week of October 3-7, you will have a “Kickoff Meeting” with your TA mentor, where you will meet your TA mentor and have the opportunity to share any early ideas that you might want feedback on before submitting the project pitch. Once project begins in full force, you will have weekly meetings with your TA mentor (scheduled at your team’s and the TA’s convenience) in order to help ensure that you are making progress on the project, and to help address problems that you encounter (be they technical or non-technical problems). Preliminary Project Plan . All projects will involve frontend and backend development of a new feature for Covey.Town. Once teams have been formed, you and your team will decide what kind of new feature you would like to build. Your feature should be something that can be implemented within the timeframe allotted (5-7 weeks), and will be implemented in a fork of the main Covey.Town codebase. Given that you will be up-to-speed on the Covey.Town codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of three or four, we expect that the feature that you propose will be more complex than the feature implemented in the individual homeworks. The project plan will focus on two sections: . | User stories and conditions of satisfaction that describe the feature that you plan to implement. | Work breakdown: Map your user stories to engineering tasks. Assign each task to a team member (or pair of team members), provide an estimate for how long each task will take, a rationale for that estimate, and schedule those stories into sprints. | . Creating a GitHub Repository . Your team’s development must take place within a private GitHub repository in our GitHub Classroom. To create your repository, each member of your team should follow these instructions: . | Sign in to GitHub.com, and then use our invitation to create a repository with the covey.town codebase. Check to see if one of your groupmates has created a group already - if so, select it to join it. Otherwise, you should enter your group number (e.g. “Group 7Y”) as the team name. | Refresh the page, and it will show a link to your new repository, for example: https://github.com/neu-cs4530/fall22-team-project-group-7y. Click the link to navigate to your new repository. This is the repository you will use for the project. | . This repository will be private, and visible only to your team and the course staff. After the semester ends, you are welcome to make it public - you have complete administrative control of the repository. Revised Project Plan . Based on the feedback that you receive from the course staff, you will revise your preliminary project plan, creating a more detailed plan to implement your new feature. The project plan will include: . | Revised user stories and conditions of satisfaction (based on feedback on the preliminary project plan) | Revised work breakdown (based on feedback on the preliminary project plan) | . Your team will self-organize, as agile teams do, and will use the work breakdown and schedule as the basis for weekly check-ins with your team’s TA. Project Implementation and Documentation . You will be assigned a mentor for your project who will work closely with you for the entire project. You will coordinate with the mentor to setup weekly meetings and regular sprint demos. Peer evaluation will also be used. Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Optionally, you may also open a pull request to merge your feature into our main repository (submitting a pull request, or the pull request being merged into our codebase is independent of the grade you receive, but provides a platform for more visiblity of your project). Your final team deliverable will include: . | The implementation of your new feature | Automated tests for your new feature | A report | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own, which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any procesess that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . The details for the final project deliverable will be released by October 26th. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-overview",
    "relUrl": "/assignments/project-overview"
  },"67": {
    "doc": "Project Plan",
    "title": "Project Plan Due Wednesday October 12, 11:00am ET",
    "content": "All projects will involve frontend and backend development of a new feature for Covey.Town. Once teams have been formed, you and your team will decide what kind of new feature you would like to build. Your feature should be something that can be implemented within the timeframe allotted (5 weeks, plus 2 weeks of planning), and will be implemented in a fork of the main Covey.Town codebase. You can play with a demo deployment of the app at app.covey.town, and in the coming weeks, we will provide tutorials and instructions for you to run the entire application in a local development environment, and also to deploy it to the cloud. Given that you will be up-to-speed on the Covey.Town codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of four, we expect that the feature that you propose will be at least as complex as the feature implemented in the individual homeworks. Feel free to look at existing systems like Gather.Town, Sococo, Reslash, Screen, and Gatherly.IO for inspiration on new features to build for Covey.Town. Also see the recent NYTimes Magazine article The Race to Fix Fix Virtual Meetings (click here to access through NEU libraries). Examples of features that students might propose include: . | Create some new form of “Interactable” object, such as a whiteboard or game | Create an interface for uploading and choosing between different maps and avatars (will require also learning to use the Phaser3 API) | Add screenreader support - generate a textual representation of the map and what players can do to interact with it | Support real persistence: store data in a database (e.g. Postgres + GraphQL), allow users to register and save a profile (e.g. using Auth0) | Add direct messaging, image messaging, and other chat features | . Please note that multiple teams might choose to propose the same feature, or a variation of that same feature - this is OK. When considering your project, please keep in mind that you will be allowed to publicly post your project online: while your immediate audience for the project is the course staff, if you are ultimately looking for software engineering jobs or co-ops, this project can be a useful piece of your portfolio. If you build a sufficiently maintainable feature (i.e., if your project is particularly well architected and tested), we will also consider pull requests to merge your feature into the main Covey.Town codebase on GitHub, allowing you to also tell recruiters that you have contributed a feature to an open source project on GitHub! . The project plan will include: . | Introductory problem statement | User stories and acceptance criteria: high level description of how users will interact with your new feature. | Work breakdown: Define engineering tasks that will be necessary to implement your new feature. Map each task to a sprint. | . Your assigned TA mentor will review your project plan and provide you with feedback on the scope and details provided in this plan. Your team will self-organize, as agile teams do, and will enhance and adapt its plan during the project lifecycle. As such, the primary goal of this document is to begin the planning process, and not to produce a detailed plan that must be followed precisely. The course staff will provide feedback on your project to help ensure that the scope of your project is appropriate. We list page maximums for each section as general guidance of what we are willing to grade. Please do not feel compelled to use all of the pages provided, and remember that a diagram or table can be as expressive (or more) as a comparable amount of text. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan#project-plan-due-wednesday-october-12-1100am-et",
    "relUrl": "/assignments/project-plan#project-plan-due-wednesday-october-12-1100am-et"
  },"68": {
    "doc": "Project Plan",
    "title": "Problem Statement, User Stories and Acceptance Criteria (max 4 pages)",
    "content": "Your project plan should begin with a 1-3 paragraph introductory problem statement: what problem in Covey.Town does your (proposed) feature solve? Provide a paragraph (or two) that describes why you are interested in building this feature. Given the problem statement, develop three user stories that show how a user would interact with the feature. User stories are requirements specified in the format “As a &lt; type of user &gt;, I want &lt; some goal &gt; so that &lt; some reason &gt;.” My conditions of satisfaction are &lt; list of common cases and special cases that must work &gt;. You should include three different user stories to describe how users will interact with your feature. Your three user stories should cover the key behavior that your feature will provide. Do not provide more than three user stories. Your problem statement and description of user stories and conditions of satisfaction should be between 2-4 pages. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan#problem-statement-user-stories-and-acceptance-criteria-max-4-pages",
    "relUrl": "/assignments/project-plan#problem-statement-user-stories-and-acceptance-criteria-max-4-pages"
  },"69": {
    "doc": "Project Plan",
    "title": "Work Breakdown (max 10 pages)",
    "content": "Given the project concept that you have chosen and the functionality that you expect to implement to satisfy your user stories, define a breakdown of the work that will be necessary to complete the project. A work breakdown includes all of the tasks necessary to accomplish the project, and will be an artifact that we will refer back to throughout the project to evaluate whether you are making satisfactory progress. Consider all of the kinds of tasks that your team will need to perform, including knowledge acquisition, design, implementation, testing and documentation tasks. It is hard to say (generically) how many work items are necessary. Each task on the work breakdown should be assigned to exactly one team member, who should provide a “T-Shirt” estimate for how long it will take (along with a justification for that estimate). Consider the dependencies between tests: perhaps an API needs to be designed and specified before implementation can begin; perhaps your development environment needs to be configured before anything else can proceed. Assign tasks to sprints considering these dependencies. Given the preliminary nature of your project, we do not expect that you will know all of the details about precisely how to implement your feature such that you could break it down into tasks that you feel could be implemented in a day or two. However: Large tasks (those which you can not provide a responsible estimate for) must be accompanied by smaller “research” tasks that can be performed early on in the project, providing clear deadlines by which the task must either be refined into smaller tasks (based on new knowledge gathered), or reworked/abandoned. You might consider even scheduling some of these research tasks to take place during Sprint 0 (immediately after submitting this document). For example: Consider if you were proposing the “Viewing Area” project (the individual project), without the experience of having completed it. It might be difficult to consider how to break down a task like “Implement the frontend components for sychnronized video playback” into something that you could commit to doing within a day or two. Given that this is a task that can be delayed until the end of the project (no other tasks depend on it), it would be wise to consider having some tasks early on in the project, such as: “Find react components that embed YouTube videos,” and “Implement simple video player that does not synchronize playback.” Completing these smaller tasks early would let you both demonstrate that some forward progress is being made, and also allow you to create a much more responsible estimate for how that last, otherwise insurmountably large task would take. Be realistic, and leave time for contingencies (including the time around the midterm exam on Nov 4). Remember that you will need to have a demo prepared of your feature by 11/30 - just 6 weeks from the due date of this assignment. If you are uncertain that some tasks will be feasible, then be sure to include evaluation tasks earlier-on in the project that will allow for “go/no-go” decisions to move forward on a task or drop it. We understand that it is quite difficult to estimate the technical complexity of a new project (as you are doing in the case of this course). We will provide you with feedback on this preliminary project plan, which you will use to produce a revised project plan (due Oct 26). Throughout the project period, teams will meet regularly with their dedicated TA Mentor, who will help track progress on a week-to-week basis and help to determine when adjustments to the project scope are needed. Each work item should contain the following information: . | Task to be performed | User story (or stories) that this task relates to | Team member responsible for completing the task | T-shirt size estimate of how long will be needed to complete the task, using the following buckets: . | Small: Can likely be completed by one team member in one sitting of less than 3-4 hours | Medium: Likely to require involvement of multiple team members, over the course of 1-2 days | Large: Currently unable to provide a responsible estimate. | . | A brief (1-2 sentence max) justification of how you reached the size estimate of the task | Milestone for delivering the task, chosen from one of the following: . | Sprint 0: Oct 12-Oct 26 | Sprint 1: Oct 27-Nov 2 (Sprint 1 is just a single week) | Sprint 2: Nov 3-Nov 16 | Sprint 3: Nov 17-Nov 30 | . | . Your work breakdown should take the format of a simple textual list. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan#work-breakdown-max-10-pages",
    "relUrl": "/assignments/project-plan#work-breakdown-max-10-pages"
  },"70": {
    "doc": "Project Plan",
    "title": "Submission",
    "content": "Your project plan should be submitted as a single PDF in GradeScope to the assignment “Preliminary Project Plan.” Each team submits a single document to GradeScope: when uploading the submission, GradeScope will ask you who your teammates are, and then will associate this submission with every member of your team. Be sure to tag your team mates. This assignment is due Oct 12 at 11am. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan#submission",
    "relUrl": "/assignments/project-plan#submission"
  },"71": {
    "doc": "Project Plan",
    "title": "Grading",
    "content": "The project plan will account for 10% of your project grade, and will be graded out of 100 points. The grading of the project plan is further broken down as follows: . Introductory problem statement (5 points): . | Receive full marks if there is a narrative consisting of 4-10 sentences that describes a specific problem that your project aims to solve. | Receive partial credit if the narrative is present, but does not describe a problem that the project aims to solve | . User stories (15 points): . Each of the three user stories will account for 5% of your grade on this assignment and graded as follows: . | Receive full marks if: . | The user story fits the problem statement | The user story satisfies the INVEST criteria for good user stories (construed quite broadly) | The user story includes conditions of satisfaction that cover the “normal” expected behavior of the feature, and any relevant error cases | . | . Work breakdown (80 points): . Your work breakdown will be evaluated holistically on the following rubric: . Coverage of tasks needed (20 points): . Receive full marks if the work breakdown includes all (reasonably expected) tasks to implement your feature, considering these kinds of tasks: . | Background research | Design of interfaces and data types | Deployment of third-party services | Implementation | Testing | Documentation | . It is not possible to state generically for all projects whether all of the above types of tasks are necessary. However, we believe that this list is exhaustive (we do not expect other kinds of tasks). Assignment of tasks (10 points): . Receive full marks if: . | Each element on the work breakdown is assigned to one team member | The distribution of tasks of each size are roughly similar between the whole team (no single person is assigned significantly more or fewer tasks of one size) | . Sizing of tasks (40 points): . Receive full marks if each element on the work breakdown: . | Has a size estimate (small, medium, or large) that is provided by the team member assigned the task. | Has a responsible justification for that estimation | Every “large” task: . | Is accompanied by a reasonable explanation of why the team is unnable to provide a responsible estimate | Is accompanied by at least one small or medium task, scheduled well-before the “large” task is due to be completed. We would expect that most of these research tasks are scheduled to sprint 0, or perhaps sprint 1. | . | . Scheduling of tasks (10 points): . Receive full marks if each element on the work breakdown: . | Is assigned to a sprint | There are no obvious constraint violations (tasks that logically must happen before others should be scheduled before them) | There are no “Large” tasks scheduled in sprint 0 | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan#grading",
    "relUrl": "/assignments/project-plan#grading"
  },"72": {
    "doc": "Project Plan",
    "title": "Project Plan",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-plan",
    "relUrl": "/assignments/project-plan"
  },"73": {
    "doc": "Project Showcase",
    "title": "Group 401: Soccer Area",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-401-soccer-area",
    "relUrl": "/assignments/project-showcase#group-401-soccer-area"
  },"74": {
    "doc": "Project Showcase",
    "title": "Group 402: Blackjack",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-402-blackjack",
    "relUrl": "/assignments/project-showcase#group-402-blackjack"
  },"75": {
    "doc": "Project Showcase",
    "title": "Group 404: File Sharing",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-404-file-sharing",
    "relUrl": "/assignments/project-showcase#group-404-file-sharing"
  },"76": {
    "doc": "Project Showcase",
    "title": "Group 405: Dynamic Map",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-405-dynamic-map",
    "relUrl": "/assignments/project-showcase#group-405-dynamic-map"
  },"77": {
    "doc": "Project Showcase",
    "title": "Group 407: Dance Dance Revolution",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-407-dance-dance-revolution",
    "relUrl": "/assignments/project-showcase#group-407-dance-dance-revolution"
  },"78": {
    "doc": "Project Showcase",
    "title": "Group 410: Wardrobe Area",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-410-wardrobe-area",
    "relUrl": "/assignments/project-showcase#group-410-wardrobe-area"
  },"79": {
    "doc": "Project Showcase",
    "title": "Group 411: Streaming Area",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-411-streaming-area",
    "relUrl": "/assignments/project-showcase#group-411-streaming-area"
  },"80": {
    "doc": "Project Showcase",
    "title": "Group 412: Closet Area",
    "content": "Demo . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase#group-412-closet-area",
    "relUrl": "/assignments/project-showcase#group-412-closet-area"
  },"81": {
    "doc": "Project Showcase",
    "title": "Project Showcase",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/project-showcase",
    "relUrl": "/assignments/project-showcase"
  },"82": {
    "doc": "Other Resources",
    "title": "Other Resources",
    "content": "There are many articles, blogs, books and podcasts that are very interesting for more reading on the topics discussed in class. We’ll update this list as the semester goes, and if you have suggestions of materials to share, please let us know and we’ll add it to the list. Podcasts . The Software Engineering Radio podcast (also available wherever you get your podcasts) aims to produce educational material for professional softare developers, and includes conversations between experts and researchers on various software engineering topics. Here are a few of our favorites that are most relevant to topics that we cover in this class: . | Donny Nadolny on Debugging Distributed Systems, with Robert Blumen, 2017 | Jafar Soltani on Continuous Delivery for Multiplayer Games, with Nate Black, 2018 | Chris Richardson on Microservice Patterns, with Robert Blumen, 2019 | Margaret Burnett on Gender, Cognitive Styles and Usability Bugs, with Felienne Hermans, 2019 | Michaela Greiler on Code Reviews, with Felienne Hermans, 2020 | Ipek Ozkaya on Managing Technical Debt, 2021 | . Code style . | Research paper: To camelcase or under_score, Dave Binkley et al | Book (free via library): “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | . Debugging . | Book (free via library): “Effective Debugging: 66 Specific Ways to Debug Software and Systems” by Diomidis SpinellisA helpful guidebook for debugging, laying out different strategies that are effective for testing different kinds of debugging hypotheses. | . Design Patterns . | Book (free via library): “Design Patterns Explained: A New Perspective on Object-Oriented Design” by Alan Shalloway and James TrottIn-depth coverage of design patterns, considering why they are important in software development, how to apply them, and descriptions of some common patterns. | Book (free via library): “Refactoring to Patterns” by Joshua KerievskyA unification of the classic Gang of Four Design Patterns work with Fowler’s refactoring work, with practical example of how to introduce patterns into existing code bases to improve code quality. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | . Infrastructure + Operations . | Book (free via library) “Site Reliability Engineering” By Betsy Beyer, Chris Jones, Niall Richard Murphy, Jennifer Petoff Site Reliability Engineering is a topic very related to software engineering: while software engineers might focus primarily on the design and development of software systems, SRE’s are engineers who focus on the deployment, monitoring and maintenance of that software. This book documents the SRE practices at Google. | . JavaScript . | Book (free via library): “Modern JavaScript for the Impatient” by Cay Horstmann | . Program Understanding . | Book: “The Programmer’s Brain” by Felienne Hermans A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/resources/",
    "relUrl": "/resources/"
  },"83": {
    "doc": "Revised Project Plan",
    "title": "Revised Project Plan Due Wednesday October 26, 11:00am ET",
    "content": "You should use the feedback on your preliminary project plan to revise the scope of your project, and discuss any changes with your assigned TA. The goal of this assignment is to finalize the intended scope of your project based on these discussions and to outline the tasks that you will need to accomplish in order to complete your project. Your assigned TA mentor will review your project plan and provide you with feedback on the scope and details provided in your preliminary plan. In this deliverable, you will revise your project plan based on that feedback, and any preliminary research tasks that you have completed. If there were any deficiencies or concerns noted by your TA mentor on your preliminary plan, you must address those concerns in this revised plan. If you are unsure of how to address any of these concerns or if you have addressed them, please discuss them with your TA mentor before submitting this revised plan. We list page maximums for each section as general guidance of what we are willing to grade. Please do not feel compelled to use all of the pages provided, and remember that a diagram or table can be as expressive (or more) as a comparable amount of text. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan#revised-project-plan-due-wednesday-october-26-1100am-et",
    "relUrl": "/assignments/revised-project-plan#revised-project-plan-due-wednesday-october-26-1100am-et"
  },"84": {
    "doc": "Revised Project Plan",
    "title": "Revised Problem Statement, User Stories and Acceptance Criteria (max 4 pages)",
    "content": "Your project plan should begin with a 1-3 paragraph introductory problem statement: what problem in Covey.Town does your (proposed) feature solve? Provide a paragraph (or two) that describes why you are interested in building this feature. Given the problem statement, develop three user stories that show how a user would interact with the feature. User stories are requirements specified in the format “As a &lt; type of user &gt;, I want &lt; some goal &gt; so that &lt; some reason &gt;.” My conditions of satisfaction are &lt; list of common cases and special cases that must work &gt;. Please make sure that your conditions of satification are complete (i.e., cover all common cases) and can be turned into testable behaviors. You should include three different user stories to describe how users will interact with your feature. Your three user stories should cover the key behavior that your feature will provide. Do not provide more than three user stories. Your problem statement and description of user stories and conditions of satisfaction should be between 2-4 pages. This revised project plan should be a standalone document (it is OK to copy/paste from the preliminary plan in this case). Mandatory update for all teams: Along with each condition of satisfaction, indicate its priority (high, medium, low). The priority should help refine your task breakdown. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan#revised-problem-statement-user-stories-and-acceptance-criteria-max-4-pages",
    "relUrl": "/assignments/revised-project-plan#revised-problem-statement-user-stories-and-acceptance-criteria-max-4-pages"
  },"85": {
    "doc": "Revised Project Plan",
    "title": "Revised Work Breakdown (max 10 pages)",
    "content": "Given the project concept that you have chosen and the functionality that you expect to implement to satisfy your user stories, define a breakdown of the work that will be necessary to complete the project. A work breakdown includes all of the tasks necessary to accomplish the project, and will be an artifact that we will refer back to throughout the project to evaluate whether you are making satisfactory progress. Consider all of the kinds of tasks that your team will need to perform, including knowledge acquisition, design, implementation, testing and documentation tasks. It is hard to say (generically) how many work items are necessary. Each task on the work breakdown should be assigned to exactly one team member, who should provide a “T-Shirt” estimate for how long it will take (along with a justification for that estimate). Consider the dependencies between tests: perhaps an API needs to be designed and specified before implementation can begin; perhaps your development environment needs to be configured before anything else can proceed. Assign tasks to sprints considering these dependencies. Given the preliminary nature of your project, we do not expect that you will know all of the details about precisely how to implement your feature such that you could break it down into tasks that you feel could be implemented in a day or two. However: Large tasks (those which you can not provide a responsible estimate for) must be accompanied by smaller “research” tasks that can be performed early on in the project, providing clear deadlines by which the task must either be refined into smaller tasks (based on new knowledge gathered), or reworked/abandoned. You might consider even scheduling some of these research tasks to take place during Sprint 0 (immediately after submitting this document). For example: Consider if you were proposing the “Viewing Area” project (the individual project), without the experience of having completed it. It might be difficult to consider how to break down a task like “Implement the frontend components for sychnronized video playback” into something that you could commit to doing within a day or two. Given that this is a task that can be delayed until the end of the project (no other tasks depend on it), it would be wise to consider having some tasks early on in the project, such as: “Find react components that embed YouTube videos,” and “Implement simple video player that does not synchronize playback.” Completing these smaller tasks early would let you both demonstrate that some forward progress is being made, and also allow you to create a much more responsible estimate for how that last, otherwise insurmountably large task would take. Be realistic, and leave time for contingencies (including the time around the midterm exam on Nov 4). Remember that you will need to have a demo prepared of your feature by 11/30 - just 6 weeks from the due date of this assignment. If you are uncertain that some tasks will be feasible, then be sure to include evaluation tasks earlier-on in the project that will allow for “go/no-go” decisions to move forward on a task or drop it. We understand that it is quite difficult to estimate the technical complexity of a new project (as you are doing in the case of this course). We will provide you with feedback on this preliminary project plan, which you will use to produce a revised project plan (due Oct 26). Throughout the project period, teams will meet regularly with their dedicated TA Mentor, who will help track progress on a week-to-week basis and help to determine when adjustments to the project scope are needed. Each work item should contain the following information: . | Task to be performed | User story (or stories) that this task relates to | Team member responsible for completing the task | T-shirt size estimate of how long will be needed to complete the task, using the following buckets: . | Small: Can likely be completed by one team member in one sitting of less than 3-4 hours | Medium: Likely to require involvement of multiple team members, over the course of 1-2 days | Large: Currently unable to provide a responsible estimate. | . | A brief (1-2 sentence max) justification of how you reached the size estimate of the task | Milestone for delivering the task, chosen from one of the following: . | Sprint 0: Oct 12-Oct 26 | Sprint 1: Oct 27-Nov 2 (Sprint 1 is just a single week) | Sprint 2: Nov 3-Nov 16 | Sprint 3: Nov 17-Nov 30 | . | . Your work breakdown should take the format of a simple textual list. Mandatory update for all teams: Even if your work breakdown is entirely unchanged compared to the preliminary plan, please be certain to include updates on all “sprint 0” tasks (those which were scheduled to be completed before the due date of this revised plan). Many teams included research/learning tasks in the first week to help inform the rest of the work breakdown: you should be certain to revise your work breakdown based on what you have learned so far. Changelog: . | 10/21: Updated details about conditions of satisfaction (being testable and include priority). Also updated the grading breakdown. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan#revised-work-breakdown-max-10-pages",
    "relUrl": "/assignments/revised-project-plan#revised-work-breakdown-max-10-pages"
  },"86": {
    "doc": "Revised Project Plan",
    "title": "Submission",
    "content": "Your revised project plan should be submitted as a single PDF in GradeScope to the assignment “Revised Project Plan.” Each team submits a single document to GradeScope: when uploading the submission, GradeScope will ask you who your teammates are, and then will associate this submission with every member of your team. Be sure to tag your team mates. This assignment is due Oct 26 at 11am. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan#submission",
    "relUrl": "/assignments/revised-project-plan#submission"
  },"87": {
    "doc": "Revised Project Plan",
    "title": "Grading",
    "content": "The revised project plan will account for 10% of your project grade, and will be graded out of 100 points. The grading of the revised project plan is further broken down as follows: . Introductory problem statement (5 points): . | Receive full marks if there is a narrative consisting of 4-10 sentences that describes a specific problem that your project aims to solve. | Receive partial credit if the narrative is present, but does not describe a problem that the project aims to solve | . User stories (45 points): . Each of the three user stories will account for 5% of your grade on this assignment and graded as follows: . | Receive full marks if: . | The user story fits the problem statement | The user story satisfies the INVEST criteria for good user stories (construed quite broadly) | The user story includes conditions of satisfaction that cover the “normal” expected behavior of the feature, and any relevant error cases | Conditions of satisfaction can be turned into Testable behaviors | Conditions of satisfaction are prioritized | . | . Work breakdown (50 points): . Your work breakdown will be evaluated holistically on the following rubric: . Coverage of tasks needed (20 points): . Receive full marks if the work breakdown includes all (reasonably expected) tasks to implement your feature, considering these kinds of tasks: . | Background research | Design of interfaces and data types | Deployment of third-party services | Implementation | Testing | Documentation | . It is not possible to state generically for all projects whether all of the above types of tasks are necessary. However, we believe that this list is exhaustive (we do not expect other kinds of tasks). Assignment of tasks (5 points): . Receive full marks if: . | Each element on the work breakdown is assigned to one team member | The distribution of tasks of each size are roughly similar between the whole team (no single person is assigned significantly more or fewer tasks of one size) | . Sizing of tasks (20 points): . Receive full marks if each element on the work breakdown: . | Has a size estimate (small, medium, or large) that is provided by the team member assigned the task. | Has a responsible justification for that estimation | Every “large” task: . | Is accompanied by a reasonable explanation of why the team is unnable to provide a responsible estimate | Is accompanied by at least one small or medium task, scheduled well-before the “large” task is due to be completed. We would expect that most of these research tasks are scheduled to sprint 0, or perhaps sprint 1. | . | . Scheduling of tasks (5 points): . Receive full marks if each element on the work breakdown: . | Is assigned to a sprint | There are no obvious constraint violations (tasks that logically must happen before others should be scheduled before them) | There are no “Large” tasks scheduled in sprint 0 | Tasks scheduled to be completed before 10/26 have an update as to their status, and the work breakdown is updated to reflect the result of these tasks. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan#grading",
    "relUrl": "/assignments/revised-project-plan#grading"
  },"88": {
    "doc": "Revised Project Plan",
    "title": "Revised Project Plan",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/assignments/revised-project-plan",
    "relUrl": "/assignments/revised-project-plan"
  },"89": {
    "doc": "Section 2 - Calendar",
    "title": "Section 2 - Calendar",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/calendar/s2",
    "relUrl": "/calendar/s2"
  },"90": {
    "doc": "Section 3 - Calendar",
    "title": "Section 3 - Calendar",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/calendar/s3",
    "relUrl": "/calendar/s3"
  },"91": {
    "doc": "Section 4 - Calendar",
    "title": "Section 4 - Calendar",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/calendar/s4",
    "relUrl": "/calendar/s4"
  },"92": {
    "doc": "Section 5 - Calendar",
    "title": "Section 5 - Calendar",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/calendar/s5",
    "relUrl": "/calendar/s5"
  },"93": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": "Given the synchronization amongst the sections, and the academic calendar starting on a Wednesday, the course material generally is designed to run on weeks from Wednesday-Tuesday. We provide a schedule for each section: . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/calendar/",
    "relUrl": "/calendar/"
  },"94": {
    "doc": "Staff",
    "title": "Staff",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/staff/",
    "relUrl": "/staff/"
  },"95": {
    "doc": "Staff",
    "title": "Office Hours",
    "content": "All office hours will be held virtually. Links to join the TA and instructor office hours are posted in Canvas. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/staff/#office-hours",
    "relUrl": "/staff/#office-hours"
  },"96": {
    "doc": "Staff",
    "title": "Instructors",
    "content": "Jonathan Bell . j.bell@northeastern.edu . Section: CS4530 Section 4 . Office Hours: . | In-Person: Tuesdays 1-2pm, 350 WVH | Virtually: Fridays 1-2pm by zoom (use your @northeastern.edu zoom account)” | . Adeel Bhutta . a.bhutta@northeastern.edu . Section: CS4530 Sections 2 &amp; 3 . Office Hours: . | In-Person: Monday 130-230pm, Meserve 337 | Virtually: Thursday 130-230pm (by zoom) | . Mitch Wand . wand@ccs.neu.edu . Section: CS4530 Section 5 . Office Hours: Tues 11-12, https://northeastern.zoom.us/s/93308973896 . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/staff/#instructors",
    "relUrl": "/staff/#instructors"
  },"97": {
    "doc": "Staff",
    "title": "Teaching Assistants",
    "content": "Aishwarya Gopal Sharma . sharma.ai@northeastern.edu . Bhupesh Digambar Patil . patil.bhu@northeastern.edu . Ferran Sulaiman . sulaiman.f@northeastern.edu . Jayraj Rameshchandra Thakor . thakor.j@northeastern.edu . Kartik Tickoo . tickoo.k@northeastern.edu . Muskaan Nandu . nandu.mu@northeastern.edu . Pak Yan (Amy) Ying . ying.p@northeastern.edu . Rumjhum Singru . singru.r@northeastern.edu . Sanjana Dabbiru . dabbiru.sa@northeastern.edu . Shashwat Rathod . rathod.sh@northeastern.edu . Sindhu Krovvidi . krovvidi.si@northeastern.edu . Vaishnavi Rakeshbhai Shah . shah.vais@northeastern.edu . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/staff/#teaching-assistants",
    "relUrl": "/staff/#teaching-assistants"
  },"98": {
    "doc": "Code Style",
    "title": "Code Style",
    "content": "Programs are easier to read and to understand when they are written in a familiar style and follow standard coding conventions. Most organizations that develop software therefore require programmers to write programs that follow the organization’s preferred style and coding conventions. These conventions can be very elaborate. Many of the guidelines are, in fact, arbitrary. When you are working on a coding project with other developers, different developers often have preference for slightly different syntax, for instance: should our string literals be enclosed by single quotes (') or double quotes (\")? Should files be indented with spaces or tabs? In TypeScript, there are often multiple ways to accomplish the same goal, for instance, you could create a new empty array with the expression const myArray = new Array(), or const myArray = []. Sometimes there is no difference between these variants except for how it reads, and other times there may be unintended consequences of making the seemingly correct but subtly wrong choice. Thankfully, it is possible to write automated checkers (and, at times, fixers) for these style violations. All code that you write for this class will be checked by ESLint, and must be free of style warnings and errors. Our ESlint rules are derived from Airbnb’s JavaScript Style Guide, ESLint’s Recommended Rules, TypeScript/ESLint Recommended Rules, React ESLint Rules and React Hooks ESLint Rules. We do not suggest studying these lists directly, instead, begin writing code naturally, and allow your IDE’s built-in style checker to report issues as you find them. The most important rules to get started are: . | Indent using spaces, not tabs; use 2 spaces for each level of indentation | Enclose all string literals with single quotes, not double | Variables must be named using lowerCamelCase, types are named using UpperCamelCase. Constants (read-only variables that are assigned a static value once and not reused) must be named using UPPER_CASE_WITH_UNDERSCORES. | The maximum line length is 100 characters | . Naming . While the linter can automatically flag names that violate camelCase rules, it can not automatically determine that a name is “good” - this is a subjective judgement call. Please consider the following when choosing names: . | Names should be informative (e.g lineTooLong() rather than checkLineLength()) | Names for types are typically nouns or noun phrases. Interface names, however, might be adjectives (e.g. Serializable). Class names may be noun phrases that include the interface name (e.g. CuckooClock and DigitalClock for classes that implement the interface Clock). | Use noun-like names for functions or methods that return values (e.g. circleDiameter rather than calculateDiameter). (Exception: simple getters can still have names that begin with get). | Reserve verb-like names for functions that perform actions (e.g. addItem). | Use adjective phrases for predicates when possible (e.g. line.tooLong()) | Variable and property names should be descriptive of what the variable is for, and not be named after the type of the variable (which is captured in the variable’s type declaration) | Names for properties that are private must start with a _ | . Documentation and Comments . All public properties and methods (other than getters, setters, and constructors) must be documented using JSDoc-style comments that describes what the property/method does. Example: . /** The unique identifier for this player * */ private readonly _id: string; . /** * A handler to process a remote player's subscription to updates for a room * * @param socket the Socket object that we will use to communicate with the player */ . Consider adding comments within your code to describe non-obvious behavior, or to capture why the code is written the way that it is. Do not add comments that simply restate what can already be immediately discerned by reading the code. For example, here is a useful comment: . // No valid session exists for this token, hence this client's connection should be terminated socket.disconnect(true); return; . Here is a useless comment on the same code snippet: . // Disconnect the socket socket.disconnect(true); return; . Comments are for documentation, not for keeping track of old code you are no longer using (do not submit commented-out code). ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/policies/style/",
    "relUrl": "/policies/style/"
  },"99": {
    "doc": "Textbooks",
    "title": "Textbooks",
    "content": "This class is a survey of many sub-areas of software engineering, and an unfortunate result of this is that there is no single textbook that is appropriate for this class. However, there are several texts that have chapters that are quite relevant, and most of these books are available for free for Northeastern students through O’Reilly’s Safari Books online. To create your account, first visit this page: https://www.safaribooksonline.com/library/view/temporary-access/ and then select “Not Listed? Click Here” for institution, then enter your @northeastern.edu email address. After this first account creation, you’ll be able to log in directly to Safari Books Online with your @northeastern.edu email and no need for 2FA (hooray!). The schedule will list which chapters of which texts are relevant for each lecture: . | “Software Engineering at Google” By Titus Winters, Tom Manshreck and Hyrum Wright This book is effectively a manual that describes the software engineering practices at Google, and the rationale behind those practices | “Effective Software Testing: A Developer’s Guide” by Mauricio Aniche (Not on Safari) A focused discussion of software testing concepts, with concrete examples using popular Java testing frameworks. | “The Programmer’s Brain” by Felienne Hermans (Not on Safari) A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | “Learn React with TypeScript 3” by Carl RipponA solid reference for React, describing how to get started, plus more advanced features like React’s Router and testing using Jest | “Programming TypeScript” by Boris ChernyA useful introduction to TypeScript, written assuming familiarity with programming in languages like Java, C# or python. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/textbooks/",
    "relUrl": "/textbooks/"
  },"100": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/",
    "relUrl": "/tutorials/"
  },"101": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS",
    "content": "Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. For this class, you will need Node.js version 16 (16.17 is the latest version at time of writing, although any 16.x should work in theory). There are many ways that you can install Node.js: for instance, you can use a package manager like snap or homebrew to install it; you can download an installer directly from the Node.js website, and you can, of course, build it from source. However, due to the complexity of running different Node.js versions on the same machine, we very strongly suggest using nvm, as explained below. We recommend installing Node.js using nvm, the node version manager. When language runtimes are in active development (like Node.js is), sometimes you end up needing to have multiple versions of Node.js installed, and different projects that you work on might require different versions of Node.js. These annoyances are quite rare, but when it happens that you need to have mutliple versions of Node.js installed, it’s super handy to have your system set up already so that installing multiple versions and switching between it is easy. You can use our instructions to set up nvm even if you have previously installed Node.js. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installing-nodejs",
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs"
  },"102": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS with NVM for Windows",
    "content": ". | Download nvm-setup.zip from the most recent release of nvm-windows (at time of writing this document, version 1.1.9). | . | Extract the contents of nvm-setup.zip and run the executable nvm-setup.exe. | This should open the nvm installation wizard. | . | Accept the license agreement and click next. Continue to accept the default choices for any remaining prompts, and click “install”. If you receive messages along the lines of “NodeJS version XYZ is already installed, would you like nvm to control this installation,” select “Yes”. | Upon completion, you will see the below window . | . | Open a command prompt with administrative privileges (type cmd in the windows start bar, then select “Run as administrator”). | Verify the installation, run the command nvm version . | This should display the version of nvm installed. | | . | Run the command nvm list available to display all available NodeJS versions. | . | Install the latest LTS (Long term supported, as opposed to the “development”) version of Node.js available using the command nvm install 16.13.2. | To use this version of NodeJS, run the command nvm use 16.13.2. | Now, NodeJS should be installed and ready for use. To verify the installation run the below commands: . | node -v | npm -v | | . | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows",
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows"
  },"103": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Linux / Mac)",
    "content": ". | Run either curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash or wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash. | Close and reopen a terminal. | Verify nvm is working by entering command -v nvm. If your terminal prints out nvm, it should be working. If you see nvm: command not found or no feedback, open a new terminal and trying again or restart from step 1. | Install the latest LTS (Long term supported, as opposed to the “development”) version of Node.js by typing nvm install 16. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installation-steps-linux--mac",
    "relUrl": "/tutorials/week1-getting-started#installation-steps-linux--mac"
  },"104": {
    "doc": "Installing a Development Environment",
    "title": "Verification",
    "content": ". | Open a shell or windows powershell. | Run the command node -v . | This should print the current version of nodeJS installed (v16.x.x) | . | Run the command npm -v . | This should print the current version of npm installed (v8.x.x) | . | If you find that some other version is being used, and would like to change the default to 16, run the command nvm alias default 16 | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#verification",
    "relUrl": "/tutorials/week1-getting-started#verification"
  },"105": {
    "doc": "Installing a Development Environment",
    "title": "Installing Visual Studio Code (VSCode)",
    "content": "Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). VSCode also supports importing hotkey configurations from most other text editors and IDEs. Read more here. While you are required to use an IDE for this class, it is not mandatory to use VSCode: if you already are comfortable developing TypeScript or JavaScript in another suitable IDE (like IntelliJ), then you are welcome to continue to use that. However, VSCode is the “supported” option: if you struggle to get things like the linter set up correctly in VSCode, we will be happy to help you. However, we can’t provide such support for all IDEs. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installing-visual-studio-code-vscode",
    "relUrl": "/tutorials/week1-getting-started#installing-visual-studio-code-vscode"
  },"106": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | Administrative access on the host machine for software installation. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#pre-requisites",
    "relUrl": "/tutorials/week1-getting-started#pre-requisites"
  },"107": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Windows / Mac)",
    "content": ". | Download the VSCode installer from the VSCode website. | . | Run the installer to start the installation wizard for VSCode . | . | Accept the license agreement and click next. | . | Choose the installation directory of your choice and click next. | . | Click next on the select start menu folder screen. | . | Tick all check boxes on the select additional tasks menu and click next. | . | Review the settings on the the “Ready to install” screen and click Install to begin installation. | Once the installation is complete, you will see the below screen and you are ready to use VSCode. | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installation-steps-windows--mac",
    "relUrl": "/tutorials/week1-getting-started#installation-steps-windows--mac"
  },"108": {
    "doc": "Installing a Development Environment",
    "title": "Installation (Linux)",
    "content": ". | The above instructions for Windows/Mac should also work, but VSCode is also provided as a snap package | . | Install snap if you haven’t already by running sudo apt update and then sudo apt install snapd. | Install VSCode by running sudo snap install --classic code. | Open VSCode as an application on your desktop. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installation-linux",
    "relUrl": "/tutorials/week1-getting-started#installation-linux"
  },"109": {
    "doc": "Installing a Development Environment",
    "title": "Additional Extensions (Optional)",
    "content": "VSCode comes with a rich set of extensions to aid in software development. Below is a list of extensions that you may find useful. | GitLens - Git Supercharged | Prettier - code formatter | vscode-icons | ESLint | Andromeda (Color theme: Andromeda Colorizer) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#additional-extensions-optional",
    "relUrl": "/tutorials/week1-getting-started#additional-extensions-optional"
  },"110": {
    "doc": "Installing a Development Environment",
    "title": "Installing Extensions (eg. ESLint)",
    "content": ". | Click on the extensions tab on the left in VSCode. | Search ESLint. | Click on Install. | Done! . | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installing-extensions-eg-eslint",
    "relUrl": "/tutorials/week1-getting-started#installing-extensions-eg-eslint"
  },"111": {
    "doc": "Installing a Development Environment",
    "title": "Getting Started With Typescript",
    "content": "Typescript is a superscript of JavaScript which adds type information and other features. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#getting-started-with-typescript",
    "relUrl": "/tutorials/week1-getting-started#getting-started-with-typescript"
  },"112": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | NodeJS | VSCode (recommended but not required) | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#pre-requisites-1",
    "relUrl": "/tutorials/week1-getting-started#pre-requisites-1"
  },"113": {
    "doc": "Installing a Development Environment",
    "title": "Installation",
    "content": ". | Open VSCode and press the ctrl + ~ (Tilde or back tick key) to open a terminal. | Optionally you can open a separate shell (Do not use powershell) | . | Run the command npm install -g typescript in the terminal. | Typescript should now be installed globally and accessible from the terminal. | . | Verify the installation using the command tsc -v in the terminal. (Do NOT use powershell) . | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#installation",
    "relUrl": "/tutorials/week1-getting-started#installation"
  },"114": {
    "doc": "Installing a Development Environment",
    "title": "Hello World",
    "content": ". | Create a new directory and open it with VSCode. | Create a new file called hello-world.ts | Add the following code to the file: console.log('Hello, World!'); . | Open the terminal with ctrl + ~. | Ensure that you are in the same directory as hello-world.ts. | . | Run the command tsc hello-world.ts . | This will generate a JS file called hello-world.js | . | Run the file with node using the command node hello-world.js. | This will give the result below. | | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started#hello-world",
    "relUrl": "/tutorials/week1-getting-started#hello-world"
  },"115": {
    "doc": "Installing a Development Environment",
    "title": "Installing a Development Environment",
    "content": "This tutorial describes the basic steps needed to set up a development environment with NodeJS, TypeScript, and VisualStudio Code. At the end of this tutorial, you should have a complete local development environment that you can use to build and test code for this class. Contents: . | Installing NodeJS | Installing Visual Studio Code | Hello, World in TypeScript | . If you run into any difficulties following any of these steps, please post (in a non-private question) on Piazza. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week1-getting-started",
    "relUrl": "/tutorials/week1-getting-started"
  },"116": {
    "doc": "Typescript Basics",
    "title": "Typescript Basics",
    "content": "This tutorial describes the basic concepts and syntax of typescript with code examples. Typescript is treated here as an extension of JavaScript, but it requires no prior knowledge to follow along. You can run the examples on Online Typescript Editor . Contents: . | Types in Typescript . | Boolean | Number | BigInt | String | Arrays | Tuples | Enums | Any | Unknown | . | Variable declaration in typescript | Objects | Control Flow Statements . | Equality vs Strict Equality | . | Loops | Array Functions . | ForEach | Map | Filter | Reduce | . | Functions . | Typing the function | Invoking the function | Optional and Default Parameters | Rest Parameters | Functions as Constructors | Arrow Functions | Function Overloads | . | Classes . | Creating a class | Creating an abstract class | . | Type Aliases | Interfaces | Custom types | Generics | Modules | Object oriented programming concepts using typescript . | Inheritance | Polymorphism | Abstraction | Encapsulation | . | General Guidelines | . Typescript is a superset of JavaScript. Thus, all JavaScript code is valid Typescript code. Typescript introduces concepts of optional typing, modules, and few additional features to Javascript. Let us begin by extending JavaScript to use the features of Typescript and primitive types. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics",
    "relUrl": "/tutorials/week2-typescript-basics"
  },"117": {
    "doc": "Typescript Basics",
    "title": "Types in typescript",
    "content": "Boolean . The boolean type has two values: true and false. Example: . let a = true // boolean var b = false // boolean const c = true // true let d: boolean = true // boolean let e: true = true // true . | Usage: You can compare them (with ==, ===, ||, &amp;&amp;, and ?), negate them (with !). | . Number . Number is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN. Example: . var b = Infinity * 0.10 // number const c = 5678 // 5678 let d = a &lt; b // boolean let e: number = 100 // number let f: 26.218 = 26.218 . | Usage: Numbers can do things, like addition (+), subtraction (-), modulo (%), and comparison (&lt;). When working with long numbers, use numeric separators to make those numbers easier to read. | . BigInt . The bigint type is the set of all BigInts, and supports things like addition (+), subtraction (-), multiplication (*), division (/), and comparison (&lt;). Example: . let a = 1234n // bigint const b = 5678n // 5678n var c = a + b // bigint let d = a &lt; 1235 // boolean let e = 88.5n // Error TS1353: A bigint literal must be an integer. let f: bigint = 100n // bigint let g: 100n = 100n . | Usage: It lets you work with large integers without running into rounding errors. While the number type can only represent whole numbers it can hold numbers larger than 253 – 1. | . String . String is the set of all strings and the things you can do with them like concatenate (+), slice (.slice),etc. Example: . let a: any = 666 // any let b: any = ['danger'] // any let c = a + b // any . | Usage: Any functionality that requires the functionality of a string of characters. Here are a couple of string operations: | . charAt() : This method returns the character from the specified index. Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string, called stringName, is stringName.length – 1. Syntax: . string.charAt(index) . slice() : This method extracts a section of a string and returns a new string. Syntax: . string.slice( beginslice [, endSlice]) . split() : This method splits a String object into an array of strings by separating the string into substrings. Syntax: . string.split([separator][, limit]) . concat(): This method adds two or more strings and returns a new single string. Syntax: . string.concat(string2, string3[, ..., stringN]) . indexOf(): This method returns the index within the calling String object of the first occurrence of the specified value, starting the search at index or -1 if the value is not found. Syntax: . string.indexOf(searchValue[, fromIndex]) . Arrays . Like in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing. Arrays are iterable Objects with the keys as numbers. Example: . let a = [1, 2, 3] // number[] var b = ['a', 'b'] // string[] let c: string[] = ['a'] // string[] let d = [1, 'a'] // (string | number)[] const e = [2, 'b'] // (string | number)[] let f = ['red'] f.push('blue') let g = [] // any[] g.push(1) // number[] g.push('red') // (string | number)[] let h: number[] = [] // number[] h.push(1) // number[] . Tuples . Tuples are subtypes of array. They’re a special way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them. Example: . let a: [number] = [1] // A tuple of [first name, last name, birth year] let b: [string, string, number] = ['malcolm', 'gladwell', 1963] . | Usage: In TypeScript Tuples support optional elements too. Just like in object types, ? means “optional”. Tuples also support rest elements, which you can use to type tuples with minimum lengths. Not only do tuple types safely encode heterogeneous lists, but they also capture the length of the list they type. | . Enums . Enums are a way to enumerate the possible values for a type. They are unordered data structures that map keys to values. Example: . enum Language { English, Spanish, Russian } . | Usage: There are two kinds of enums: enums that map from strings to strings, and enums that map from strings to numbers. Use it when you wish to provide flexibility making it easier to express and document intentions and use cases or when you want to save compile-time and runtime with inline code. | . Any . The any data type is the super type of all types in TypeScript. It denotes a dynamic type. Using the any type is equivalent to opting out of type checking for a variable. Example: . let a: any = 666 // any let b: any = ['danger'] // any let c = a + b // any . | Usage: In TypeScript everything needs to have a type at compile time, and any is the default type when you (the programmer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. | . Unknown . If any is the Godfather, then unknown is Keanu Reeves as undercover FBI agent Johnny Utah in Point Break: laid back, fits right in with the bad guys, but deep down has a respect for the law and is on the side of the good guys. You can compare unknown values (with ==, ===, &amp;&amp;, and ?), and refine them (like you can any other type) with JavaScript’s typeof and instanceof operators. Example: . let a: unknown = 30 // unknown let b = a === 123 // boolean . | Usage: For the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#types-in-typescript",
    "relUrl": "/tutorials/week2-typescript-basics#types-in-typescript"
  },"118": {
    "doc": "Typescript Basics",
    "title": "Variable declaration in typescript",
    "content": "Variables can be declared in Typescript using one of 3 keywords: . | var: var declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this var-scoping or function-scoping. Parameters are also function scoped. | let: When a variable is declared using let, it uses what some call lexical-scoping or block-scoping. Unlike variables declared with var whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block. | const: They are like let declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as let, but you can’t re-assign to them. | . The syntax of declarations is as below: . var &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; let &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; const &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; . Example: . let num: number = 1; const PI: number = 3.14; let x: string = \"This is a string\"; const t: boolean = true; const f: boolean = false; let uninitialized: any; . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#variable-declaration-in-typescript",
    "relUrl": "/tutorials/week2-typescript-basics#variable-declaration-in-typescript"
  },"119": {
    "doc": "Typescript Basics",
    "title": "Objects",
    "content": ". | Objects are similar to dictionaries with key-value pairs. | Arrays are iterable Objects with the keys as numbers. | . Examples: . const myObj: any = { key1: 'value1', key2: 'value2' }; console.log(myObj.key1); // prints 'value1' . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#objects",
    "relUrl": "/tutorials/week2-typescript-basics#objects"
  },"120": {
    "doc": "Typescript Basics",
    "title": "Control Flow Statements",
    "content": "Typescript contains the following control flow statements: . | If-Else | Switch | Ternary operator: Shorthand for if-else which returns a value. | . If condition syntax: . if(condition) { // executed when condition is true } if(condition) { // executed when condition is true } else { // executed when condition is false } if(condition) { // executed when condition is true } else if(condition2) { // checked only if condition is false // executed when condition2 is true } else { // executed when all conditions in the if-elseif ladder are false. } . Switch case syntax: . switch (variable) { case &lt;case1&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing case &lt;case2&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing default: // executed if variable does not match any prior cases } . Ternary Syntax: . let x = (condition) ? /* Executed when condition is true */ : /*Executed when condition is false*/; . Examples: . const str: string = \"ABCD\"; if(str === \"ABCD\") { console.log(\"it was true\"); } else { console.log(\"it was false\"); } switch (str) { case \"ABCD\": console.log('It was ABCD'); break; case \"WXYZ\": console.log('It was WXYZ'); break; default: console.log('It was something completely different') } let y: string = (str.includes(\"A\")) ? \"The string contains A\" : \"The string does not contain A\"; // y now contains \"The string contains A\" . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#control-flow-statements",
    "relUrl": "/tutorials/week2-typescript-basics#control-flow-statements"
  },"121": {
    "doc": "Typescript Basics",
    "title": "Equality vs Strict Equality",
    "content": "Typescript/JavaScript contain 2 equality operators: . | ==: Compares only the value of entities being compared. | ===: Compares the type and value of entities being compared. | . Example: . if(0 == '0') { } // Evaluates to true despite comparing string to number. if(0 === '0') { } // Evaluated to false because types are different. We recommend using strict equality (===) in all cases, and this recommendation is enforced by our linter. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#equality-vs-strict-equality",
    "relUrl": "/tutorials/week2-typescript-basics#equality-vs-strict-equality"
  },"122": {
    "doc": "Typescript Basics",
    "title": "Loops",
    "content": "Typescript contains the following loops: . | For | While | Do-while | . Examples: . for(let i: number = 0; i &lt; 10; i++) { } while(condition) { } do { } while(condition) . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#loops",
    "relUrl": "/tutorials/week2-typescript-basics#loops"
  },"123": {
    "doc": "Typescript Basics",
    "title": "Array Functions",
    "content": "ForEach, Map, reduce, and filter are all array methods in JavaScript. Each one will iterate over an array and perform a transformation or computation. Each will return a new array based on the result of the function. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#array-functions",
    "relUrl": "/tutorials/week2-typescript-basics#array-functions"
  },"124": {
    "doc": "Typescript Basics",
    "title": "ForEach",
    "content": "forEach() method calls a function for each element in the array. It returns the resultant array. Syntax . array.forEach(callback[, thisObject]); . Example . let num = [7, 8, 9]; num.forEach(function (value) { console.log(value); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#foreach",
    "relUrl": "/tutorials/week2-typescript-basics#foreach"
  },"125": {
    "doc": "Typescript Basics",
    "title": "Map",
    "content": "It is an array function that transforms the array according to the applied function and returns the updated array. It works on each element of an array. Syntax . array.map(callback[,object]) . callback - It is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type - List . Examples . //Calculate cube of each element with the help of map. function cube(n){ return n*n*n; } var arr=new Array(1,2,3,4) var newArr=arr.map(cube); console.log(newArr) // Output : [1,8,27,64] . In the above example, a function called “cube” is created and then is passed as a callback function into map(). ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#map",
    "relUrl": "/tutorials/week2-typescript-basics#map"
  },"126": {
    "doc": "Typescript Basics",
    "title": "Reduce",
    "content": "It also works on a callback for each element of an array. It reduces the result of this callback function from one array element to the other. Syntax . array.reduce(callback[,initalValue]) . callback - this parameter is the function to execute on each value in the array. intitalValue - this parameter is the object to use as the first argument of the first call of the callback. Examples . //To calculate product of every element of an array, var arr = new Array (1,2,3,4,5) var val = arr.reduce(function(a,b){ return a*b; }); //output =&gt; 120 . Calculate the total salary from a list of object, then you will use the reduce() like, . var employees = [ { id: 20, name: 'Ajay', salary:30000 }, { id: 24, name: 'Vijay', salary:35000 }, { id: 56, name: 'Rahul', salary:32000 }, { id: 88, name: 'Raman', salary:38000 } ]; var totalSalary= employees .reduce(function (total, record) { return total + record.salary; }, 0); //It will return the total salary of all the employees. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#reduce",
    "relUrl": "/tutorials/week2-typescript-basics#reduce"
  },"127": {
    "doc": "Typescript Basics",
    "title": "Filter",
    "content": "As the name suggests it can filter out the data/array elements on the basis of condition and return the result as a list. Basically, this function pushes the current element into a new array when the callback functions return true. Syntax . array.map(callback[,object]) . callback - it is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type: List . Examples . //Calculate a list of even elements from an array : arr = new Array(1, 2, 3, 6, 5, 4) var newArr = arr.filter(function(record) { return record % 2 == 0; }); // output =&gt; [2,6,4] . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#filter",
    "relUrl": "/tutorials/week2-typescript-basics#filter"
  },"128": {
    "doc": "Typescript Basics",
    "title": "Functions",
    "content": ". | Functions usually “take in” data, process it, and “return” a result. Remember one function/method one job! . | There is a lot you can do with functions in JavaScript like assign them to variables, pass them to other functions, return them from functions, assign them to objects and prototypes, write properties to them, read those properties back, and so on, and TypeScript models all of those things with its rich type system, which we just learnt. | Typescript enables us to set the types for our function parameters and our return type. | Functions in Typescript are defined as below: . function functionName(argument1: &lt;type&gt;, defaultArgument: &lt;type&gt; = value, optionalArgument?: &lt;type&gt;): &lt;return type&gt; { // Function body } . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#functions",
    "relUrl": "/tutorials/week2-typescript-basics#functions"
  },"129": {
    "doc": "Typescript Basics",
    "title": "Typing the function",
    "content": "A simple function in javascript would look like this: . // Named function function add(a, b) { return a + b; } . Now, let’s add types to our simple examples above: . function add(a: number, b: number): number { return a + b; } . You will usually explicitly annotate function parameters (a and b in this example)—TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters. The return type is inferred, but it’s a good practice to explicitly annotate it. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#typing-the-function",
    "relUrl": "/tutorials/week2-typescript-basics#typing-the-function"
  },"130": {
    "doc": "Typescript Basics",
    "title": "Invoking the function",
    "content": "When you invoke a function in TypeScript, you don’t need to provide any additional type information—just pass in some arguments, and TypeScript will go to work checking that your arguments are compatible with the types of your function’s parameters: . add(1, 2); // evaluates to 3 . Of course, if you forgot an argument, or passed an argument of the wrong type, TypeScript will be quick to point it out: . add(1); // Error TS2554: Expected 2 arguments, but got 1. add(1, 'a'); // Error TS2345: Argument of type '\"a\"' is not assignable // to parameter of type 'number'. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#invoking-the-function",
    "relUrl": "/tutorials/week2-typescript-basics#invoking-the-function"
  },"131": {
    "doc": "Typescript Basics",
    "title": "Optional and Default Parameters",
    "content": "Like in object and tuple types, you can use ? to mark parameters as optional. When declaring your function’s parameters, required parameters have to come first, followed by optional parameters: . function log(message: string, userId?: string) { let time = new Date().toLocaleTimeString() console.log(time, message, userId || 'Not signed in') } log('Page loaded') // Logs \"12:38:31 PM Page loaded Not signed in\" log('User signed in', 'da763be') // Logs \"12:38:31 PM User signed in da763be\" . You can provide default values for optional parameters. Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do). For example, we can rewrite log as: . function log(message: string, userId = 'Not signed in') { let time = new Date().toISOString() console.log(time, message, userId) } log('User clicked on a button', 'da763be') log('User signed out') . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#optional-and-default-parameters",
    "relUrl": "/tutorials/week2-typescript-basics#optional-and-default-parameters"
  },"132": {
    "doc": "Typescript Basics",
    "title": "Rest Parameters",
    "content": "If a function takes a list of arguments, you can of course simply pass the list in as an array: . function sum(numbers: number[]): number { return numbers.reduce((total, n) =&gt; total + n, 0); } sum([1, 2, 3]); // evaluates to 6 . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#rest-parameters",
    "relUrl": "/tutorials/week2-typescript-basics#rest-parameters"
  },"133": {
    "doc": "Typescript Basics",
    "title": "Functions as Constructors",
    "content": "In Typescript/Javascript, Functions can be used as constructors for creating objects. This is similar to classes, but not quite the same. Examples: . function Person(firstName: string, lastName: string): void { this.firstName = firstName; this.lastName = lastName; this.getFullName = function(): string { return this.firstName + ' ' + this.lastName; } } const person1 = new Person('first', 'last'); console.log(person1.getFullName()); // Returns 'first last'. | Constructors can’t have type parameters - these belong on the outer class declaration . | Constructors can’t have return type annotations - the class instance type is always what’s returned ```ts class Point { x: number; y: number; . | . // Normal signature with defaults constructor(x = 0, y = 0) { this.x = x; this.y = y; } } . ## Arrow Functions Arrow Functions (also called fat arrow functions) are functions which have lexical 'this' and 'arguments'. This are especially useful in class methods to preserve the context when using higher order functions. Examples: ```ts let sum = (x: number, y: number): number =&gt; { return x + y; } sum(10, 20); //returns 30 . In the above example, sum is an arrow function. (x:number, y:number) denotes the parameter types, :number specifies the return type. The fat arrow =&gt; separates the function parameters and the function body. The right side of =&gt; can contain one or more code statements. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#functions-as-constructors",
    "relUrl": "/tutorials/week2-typescript-basics#functions-as-constructors"
  },"134": {
    "doc": "Typescript Basics",
    "title": "Function Overloads",
    "content": "In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: . //function makeDate() with one parameter function makeDate(timestamp: number): Date; //function makeDate() with three parameters function makeDate(m: number, d: number, y: number): Date; //function makeDate() with one parameter and 2 default parameters function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); //No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#function-overloads",
    "relUrl": "/tutorials/week2-typescript-basics#function-overloads"
  },"135": {
    "doc": "Typescript Basics",
    "title": "Classes",
    "content": "Classes are blueprints for creating objects. | They can contain properties, methods, and a constructor. | All members of a class can have an access modifier: public, protected, private. | Members can also be static (shared across all instances of the class) and final (immutable). | Class properties may have getters and setters. | Classes can extend other classes. | Classes can implement interfaces. | . Creating a Class . A class definition can include the following: . | Fields − A field is any variable declared in a class. Fields represent data pertaining to objects | Constructors − Responsible for allocating memory for the objects of the class | Functions − Functions represent actions an object can take. They are also at times referred to as methods | . Examples: . class Person { private firstName: string = ''; protected middleName: string; public lastName: string = ''; private static final NeverGonnaGiveYouUp: any; protected static final NeverGonnaLetYouDown: any; public static final isRickRolled: boolean = true; constructor() { // I execute when you call new Person(). // No access modifier === public by default. // Make me private if implementing a singleton. } public anyoneCanCallMe(): void { this.childClassesCanCallMe(); } protected childClassesCanCallMe(): void { this.onlyPersonCanCallMe(); } private onlyAccessibleInsidePerson(): void { // I lied, anyone can call me if you know how. // Welcome to JavaScript :p } public get firstName(): string { return this.firstName; } public set firstName(firstName: string): void { this.firstName = firstName; } } const person = Person(); person.firstName = 'first'; console.log(person.firstName); person.anyoneCanCallMe(); class SpecialPerson extends Person { // I contain everything person has, and can extend/override it. constructor() { super() // I call the constructor for Person. } } . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#classes",
    "relUrl": "/tutorials/week2-typescript-basics#classes"
  },"136": {
    "doc": "Typescript Basics",
    "title": "Creating an abstract class",
    "content": ". | Define an abstract class in Typescript using the abstract keyword. Abstract classes are mainly for inheritance where other classes may derive from them. We cannot create an instance of an abstract class. | An abstract class typically includes one or more abstract methods or property declarations. The class which extends the abstract class must define all the abstract methods. | . Example: . abstract class Person { abstract name: string; display(): void{ console.log(this.name); } } class Employee extends Person { name: string; empCode: number; constructor(name: string, code: number) { super(); // must call super() this.empCode = code; this.name = name; } } let emp: Person = new Employee(\"James\", 100); emp.display(); //James . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#creating-an-abstract-class",
    "relUrl": "/tutorials/week2-typescript-basics#creating-an-abstract-class"
  },"137": {
    "doc": "Typescript Basics",
    "title": "Type Aliases",
    "content": "We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name. A type alias is exactly that - a name for any type. The syntax for a type alias is: . type Point = { x: number; y: number; }; function printCoord(pt: Point) { console.log(\"The coordinate's x value is \" + pt.x); console.log(\"The coordinate's y value is \" + pt.y); } printCoord({ x: 100, y: 100 }); . You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type: . type ID = number | string; . Note that aliases are only aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type: . type UserInputSanitizedString = string; function sanitizeInput(str: string): UserInputSanitizedString { return sanitize(str); } // Create a sanitized input let userInput = sanitizeInput(getInput()); // Can still be re-assigned with a string though userInput = \"new input\"; . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#type-aliases",
    "relUrl": "/tutorials/week2-typescript-basics#type-aliases"
  },"138": {
    "doc": "Typescript Basics",
    "title": "Interfaces",
    "content": "Interfaces are used to define contracts for interaction with external entities. If an interface has a property/method, an Object/Class which implements it must have it. Interfaces can be used to define custom types for Objects in Typescript. Examples: . //Interface IPerson respresents a person by attributes firstName and lastName and a method to getFullName() interface IPerson { firstName: string; lastName: string; getFullName(): string; } //Class Person implements interface Iperson. Person class must contains ll the attributes and methods of interface. class Person implements IPerson { public firstName: string = ''; public lastName: string = ''; public getFullName(): string { return this.firstName + ' ' + this.lastName; } // It can contain any other properties/methods but must contain those in the interface. } const person: IPerson = new Person(); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#interfaces",
    "relUrl": "/tutorials/week2-typescript-basics#interfaces"
  },"139": {
    "doc": "Typescript Basics",
    "title": "Custom types",
    "content": ". | For complicated types (usually required for Objects), it is recommended to use an interface. | Additionally, typescript contain the ‘type’ keyword which can be used to create new types. | This is generally used when a union of different types is required. | . Examples: . interface IStudent { name: string; age: number; studentID: number; gender: string; isEnrolled: boolean; } const student: IStudent = { name: 'name', age: 20, studentID: 111111111, gender: 'hidden' isEnrolled: true; }; type StringOrNumber = string | number; let x = 1; x = 'some string'; . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#custom-types",
    "relUrl": "/tutorials/week2-typescript-basics#custom-types"
  },"140": {
    "doc": "Typescript Basics",
    "title": "Generics",
    "content": ". | Generics allow us to pass different types to a function/class making it more generalized. | This will be especially useful when working with http requests. | . Examples: . function myFunc&lt;T&gt;(data: T): T { console.log(data); return data } let x: string = myFunc&lt;string&gt;('some string'); let y: number = myFunc&lt;number&gt;(5); class myClass&lt;T&gt; { } interface IMyInterface&lt;T&gt; { } . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#generics",
    "relUrl": "/tutorials/week2-typescript-basics#generics"
  },"141": {
    "doc": "Typescript Basics",
    "title": "Modules",
    "content": "A Module in typescript is defined by using the ‘Import’ or ‘Export’ keywords within a file. Variables declared in a module are scoped locally and are not added to the global scope. | Export makes the variables and functions from a file visible outside it. | Import allows use to use variables and functions exported by another file. | . Examples: . // file1.ts export const someVar: string = 'Variables can be exported too.'; export default function add(x: number, y: number): number { return x + y; } export function subtract(x: number, y: number): number { return x - y; } function multiply(): void { throw new Error(); } // file2.ts import add from './file1'; // curly braces are not required if export default is used. // There can be only 1 export default in a while. Use it if file has only 1 export. import { subtract } from './file1'; add(1, 2); subtract(2, 1); // multiply cannot be imported. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#modules",
    "relUrl": "/tutorials/week2-typescript-basics#modules"
  },"142": {
    "doc": "Typescript Basics",
    "title": "Object oriented programming concepts using typescript",
    "content": "Object Oriented Programming or OOP is a programming paradigm that has four principles which are: . | Inheritance | Polymorphism | Abstraction | Encapsulation | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#object-oriented-programming-concepts-using-typescript",
    "relUrl": "/tutorials/week2-typescript-basics#object-oriented-programming-concepts-using-typescript"
  },"143": {
    "doc": "Typescript Basics",
    "title": "Inheritance",
    "content": "TypeScript supports the concept of Inheritance. Inheritance is the ability of a program to create new classes from an existing class. The class that is extended to create newer classes is called the parent class/super class. The newly created classes are called the child/sub classes. A class inherits from another class using the ‘extends’ keyword. Child classes inherit all properties and methods except private members and constructors from the parent class. However, TypeScript doesn’t support multiple inheritance. Syntax: . class child_class_name extends parent_class_name . Example: . //Parent class Shape class Shape { Area:number constructor(a:number) { this.Area = a } } //Child class Circle that inherits properties of Shape class Circle extends Shape { disp():void { console.log(\"Area of the circle: \"+this.Area) } } var obj = new Circle(223); obj.disp() . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#inheritance",
    "relUrl": "/tutorials/week2-typescript-basics#inheritance"
  },"144": {
    "doc": "Typescript Basics",
    "title": "Polymorphism",
    "content": "When multiple classes inherit from a parent and override the same functionality, the result is polymorphism. Each of those child classes now implements a property or method, but they each may have their own way of performing that implementation. lternatively, one child class might override the parent’s members while another child doesn’t but just accepts the parent class’s implementation instead. This also demonstrates polymorphic behavior, since those behaviors are different between the siblings. class CheckingAccount { open(initialAmount: number) { // code to open account and save in database } } class BusinessCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt; 1000) { throw new Error(\"Business accounts must have an initial deposit of 1.000 Euros\") } super.open(initialAmount); } } class PersonalCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt;= 0) { throw new Error(\"Personal accounts must have an initial deposit of more than zero Euros\") } super.open(initialAmount); } } . In the above code sample shows, the two child classes have different business rules to implement when it comes to opening an account – mainly different opening balances. Because both children have a method to open the account but both children choose to do it differently means the behavior is polymorphic. To achieve polymorphism, inherit from a base class, then override methods and write implementation code in them. In addition to overriding methods, you can overload methods to achieve polymorphism. Overloaded methods are methods that have different signatures (i.e., different data types or number of arguments) with the same name. However, in TypeScript, methods aren’t overloaded by simply modifying the types or number of arguments like in some other languages. To create an overload in TypeScript, you can either add optional arguments to a method, or overload function declarations in an interface and implement the interface. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#polymorphism",
    "relUrl": "/tutorials/week2-typescript-basics#polymorphism"
  },"145": {
    "doc": "Typescript Basics",
    "title": "Abstraction",
    "content": "Abstraction is a way to model objects in a system that creates a separation of duties between class or type and the code that inherits it. A developer creates a type, i.e., a class or interface, and that type specifies what the calling code should implement, but not how. So it’s the job of the abstract type to define what needs to be done, but up to the consuming types to actually do those things. To enforce abstraction, inherit or implement from abstract classes and interfaces. For example, some bank accounts have fees. You can create a Fee interface that defines a method for charging a fee. Fees don’t apply to all types of accounts, so it’s best to create an interface that can be applied to specific classes anywhere in the inheritance hierarchy. A checking account might charge fees, where its parent and sibling, the generic bank account and savings accounts might not. interface Fee { chargeFee(amount: number ); } // parent BankAccount and sibling SavingsAccount do not implement Fee interface class BankAccount { ... } class SavingsAccount extends BankAccount { ... } // checking implements Fee class CheckingAccount extends BankAccount implements Fee { chargeFee(amount: number) {} } . Children classes inherit interface members that have been implemented in their parent, so if a BusinessChecking account has inherited from the CheckingAccount class, then it inherits that implementation. // BusinessChecking inherits CheckingAccount and therefore Fee class BusinessChecking extends CheckingAccount { … } // Code that uses BusinessChecking can call chargeFee function CalculateMonthlyStatements() { let businessChecking = new BusinessChecking(); businessChecking.chargeFee(100); } . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#abstraction",
    "relUrl": "/tutorials/week2-typescript-basics#abstraction"
  },"146": {
    "doc": "Typescript Basics",
    "title": "Encapsulation",
    "content": "Encapsulation is a key part of Object Oriented Programming that is a way to structure code so that a certain block of code has specific access points for external code. The term for this is “visibility” or “accessibility”. Visibility defines what code from one method, property, or class can call code in another method, property, or class. In TypeScript, we enforce encapsulation with methods and properties that only allow access to data that we control. The Withdraw method below does that by doing the calculation and updating the class level _balance field. The Balance property then returns the private _balance field to the calling code. Withdraw(amount: number): boolean { if (this._balance &gt; amount) { this._balance -= amount return true; } return false; } private _balance: number; get Balance(): number { return this._balance; } . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#encapsulation",
    "relUrl": "/tutorials/week2-typescript-basics#encapsulation"
  },"147": {
    "doc": "Typescript Basics",
    "title": "General Guidelines",
    "content": ". | Naming conventions . | use kebab-case for file names. | Use camelCase for variable and function names. | Use PascalCase for Class and constructor function names. | . | Prefer descriptive names over random letters. | Although typing is optional in typescript, it is not optional for this course. | Always use strict equality. | Use a linter. (as specified on course website) | Use a prettifier. (If the linter doesn’t do it already) | Use general coding guidelines as discussed in Week1. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week2-typescript-basics#general-guidelines",
    "relUrl": "/tutorials/week2-typescript-basics#general-guidelines"
  },"148": {
    "doc": "React Tutorial",
    "title": "React Basics",
    "content": "This tutorial covers the basic concepts of react. By the end of this tutorial, you will be able to create a new react app, understand the basic concepts of react such as states and props, understand React hooks and handling events. | React Basics | Creating a new React App | Understanding a React App . | Components | Template For Structure of Function Component | Props | State | Communicating between Components . | Parent to Child | Child to Parent | . | Handling Events | . | React Hooks . | UseState | UseEffect | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#react-basics",
    "relUrl": "/tutorials/week4-react-basics#react-basics"
  },"149": {
    "doc": "React Tutorial",
    "title": "Creating a New React App",
    "content": "Let’s use npx and create-react-app to create a new React project . | npx stands for Node Package Execute. It is a runner that can execute any package that you want from the npm registry without even installing that package. In this case npx tool temporarily installs the create-react-app npm package and uses it to create our project. | create-react-app is a command-line tool that we can use to quickly create a React and TypeScript app with lots of useful pieces. | . | We use the create-react-app npm package to create a React and TypeScript project by entering the following: . npx create-react-app my-app --template typescript . | Note 1: This will create a new project directory called my-app under the current directory. | Note 2: This will create a git repo in my-app, so you probably shouldn’t do this inside a pre-existing git repository. | . | Navigate to the project directory using the command: cd my-app . | To start the development server for React, run the command: npm start . | Navigate to http://localhost:3000/ to see the default react page. | After a few seconds, a browser window opens, with our app running: | . | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#creating-a-new-react-app",
    "relUrl": "/tutorials/week4-react-basics#creating-a-new-react-app"
  },"150": {
    "doc": "React Tutorial",
    "title": "React Component",
    "content": "React follows a Component based architecture. A component is a repeatable html element with built-in state, business logic, and a lifecycle. The component may be something as simple as a single html element such as an input box, or a button, or a complex entity made up of other components. Components are the basic building blocks of a React application and they allow the developer to split the UI into independent and reusable pieces where each piece can be used in isolation. Creating A Function Component in React . view in sandbox . The simplest method to define a component is to write a function in Javascript. These components are also widely referred as functional stateless components but in the recent versions of React, they have the capabilities to contain state as well. import * as React from \"react\"; interface Props = {name?: string}; function App (props: Props) { return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Welcome to React with Typescript Tutorial.&lt;/h1&gt; &lt;/div&gt; ); } export default App; . A Few Things to Note About React Components: . | The root (App) component is the entry point for the React App and all other components are nested in it. | We define a function component using a javascript function, passing the props type in as a generic parameter. | The import statement is used to import the public classes/functions from the react library. | A function can return a single top level element. | div is the top level element in this case and other elements can be nested in it. | The attribute className is used to specify a CSS class name if CSS properties have been defined seperately for a class. | className attribute is used to set the value of an element’s class attribute. Using this property, the user can set the class of an element to the desired class. | . | . | The round brackets (()) after return are used to span a JSX/TSX element across multiple lines. | At last , the component needs to be exported from the current file, so that it can be imported somewhere else and can be used either in isolation or combination with other components for rendering on the UI. | Elements on one line can be returned directly. | Each instance of a component creates a new element independent of other instances of the component. | Each component has it’s own state, props, and lifecycle (which will be explored later in the tutorial). | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#react-component",
    "relUrl": "/tutorials/week4-react-basics#react-component"
  },"151": {
    "doc": "React Tutorial",
    "title": "Template For Structure of Function Component",
    "content": "view in sandbox . import * as React from \"react\"; interface Props = {property1?: value1, property2?: value2} function ComponentName (props: Props) { const handler = () =&gt; { ... }; return ( &lt;div&gt;Our TSX&lt;/div&gt; ); }; ComponentName.defaultProps = { ... }; export default ComponentName; . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#template-for-structure-of-function-component",
    "relUrl": "/tutorials/week4-react-basics#template-for-structure-of-function-component"
  },"152": {
    "doc": "React Tutorial",
    "title": "Props",
    "content": "view in sandbox . React components are similar to JavaScript functions and can accept arbitrary arguments called props. Since components are reusable, props are especially useful to display different content in each instance of the component. Let us extract the header elements from the previous code snippet into a new component called Header. We can then use props to say “hello” to different users. | Create a new file in src/ directory called Header.tsx | Create and export a function called Header in the file as below: ```ts import React from “react”; | . interface IProps { name?: string; } . const Header = (props: IProps) =&gt; { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }; . Header.defaultProps = { name: “World” }; . export default Header; . - The above code snippet creates a new function component `Header` and prints the value of the `name` passed in the props. - It defines a defaultProps for the component `Header` where the default value for `name` is used in case the value for props for `name` is not passed in any instance of the component. - In App.tsx: - Remove the code in h1 tags. - Import the Header component as below: - ```ts import Header from './Header'; ``` - Update the contents of return as below: - ```ts &lt;div className=\"App-header\"&gt; &lt;Header /&gt; &lt;Header name=\"John\" /&gt; &lt;Header name=\"Jane\" /&gt; &lt;/div&gt; ``` - Save all files and run npm start A few things to note from the above example: - Component.defaultProps can be used to specify default values for props. - Components are rendered to the user interface and the component’s logic contains the data to be displayed in the view(UI). - Curly braces ({}) in JSX/TSX are used as a connection between the data to be displayed in the view and the component’s logic for displaying the data in the view. - In our example, `{props.name}` will reflect the value of the property `name` in the view(html) for the cases when the values \"John\" and \"Jane\" are passed as props for the `name` property. - If no props are passed for an instance of the component, then it will display the default value of props. ## State State management is just a means of facilitating data sharing and communication among components. It creates a concrete data structure that you can read and write to reflect the state of your program. ```ts const [counter, setCounter] = useState(0) . The above snippet shows creation of counter state with an intial value of 0. Using the array destructuring syntax we extract out the state variable and the function to update the counter value. In its most basic form, a State object is a JavaScript object that represents the part of a component that can change as a result of a user’s action. States can also be thought of as a component’s memory. State update calls are asynchronous. As one cannot expect to call the update state function on one line and expect the state to be updated on the next. The reason for this is because update state methods are more of a request than an immediate order to update state. So React schedules an update to a component’s state object. When state changes, the component responds by re-rendering. Also multiple update request may be batched into one for performance reasons. Changes in state and/or props will both cause our React component to re-render. Changes in state, on the other hand, can only occur internally as a result of components modifying their own state.  . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#props",
    "relUrl": "/tutorials/week4-react-basics#props"
  },"153": {
    "doc": "React Tutorial",
    "title": "Communication Between Components:",
    "content": "Parent To Child Component Communication: . view in sandbox . Passing values from a parent component to a child component is simple. We only have to pass the values as props of the child component. The child component can then use the props object to output results. In the example code you will see that CounterContent component accepts a counter prop which is then used to display the value inside div element. import { useState } from \"react\"; interface CounterContentProps { counter: Number; } function CounterContent({ counter }: CounterContentProps) { return &lt;div&gt;Counter: {counter}&lt;/div&gt;; } function Counter() { const [counter, setCounter] = useState&lt;number&gt;(0); return ( &lt;&gt; &lt;CounterContent counter={counter} /&gt; &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Increment Count&lt;/button&gt; &lt;/&gt; ); } . Child to Parent Component Communication . view in sandbox . For passing data from child component to parent component do the following steps: . | Declare a callback function inside the parent component. This function will get data from the child component. | Pass the callback function to the child component as props. | Child then sends the update to the parent through the use of the callback function. | . In the example below we have four children components: . | CounterContent: Displays the counter value | IncrementCounterButton: Increments the counter value | DecrementCounterButton: Decrements the counter value | CustomCounterButton: Sets the counter to a particular value. | . All callback functions passed to the children component are declared in Counter function which is the parent component that maintains the state value for counter. import { useState } from \"react\"; interface CounterContentProps { counter: Number; } interface IncrementCounterButtonProps { incrementCount(): void; } interface DecrementCounterButtonProps { decrementCount(): void; } interface SetCounterButtonProps { setCount(value: number): void; } function CounterContent({ counter }: CounterContentProps) { return &lt;div&gt;Counter: {counter}&lt;/div&gt;; } /** * Child component accepts a incrementCount callback function as a props. * The callback which is declared inside the parent component triggers a state update. */ function IncrementCounterButton({ incrementCount }: IncrementCounterButtonProps) { return &lt;button onClick={() =&gt; incrementCount()}&gt;increment Count&lt;/button&gt;; } /** * Child component accepts a decrementCount callback function as a props. * The callback which is declared inside the parent component triggers a state update. */ function DecrementCounterButton({ decrementCount }: DecrementCounterButtonProps) { return &lt;button onClick={() =&gt; decrementCount()}&gt;Decrement Count&lt;/button&gt;; } function CustomCounterButton({ setCount }: SetCounterButtonProps) { // change this value to see how child passes count value data to parent through // the use of callback function const dummyValue = 100; return ( &lt;button onClick={() =&gt; setCount(dummyValue)}&gt; Set Count to {dummyValue} &lt;/button&gt; ); } /** * Parent Component where state and callbacks are maintained. **/ function Counter() { const [counter, setCounter] = useState(0); const decrementCount = () =&gt; { if (counter === 0) return; setCounter(counter - 1); }; const incrementCount = () =&gt; { setCounter(counter + 1); }; const setCount = (value: number) =&gt; { setCounter(value); }; return ( &lt;&gt; &lt;CounterContent counter={counter} /&gt; &lt;IncrementCounterButton incrementCount={incrementCount} /&gt; &lt;DecrementCounterButton decrementCount={decrementCount} /&gt; &lt;CustomCounterButton setCount={setCount} /&gt; &lt;/&gt; ); } . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#communication-between-components",
    "relUrl": "/tutorials/week4-react-basics#communication-between-components"
  },"154": {
    "doc": "React Tutorial",
    "title": "Handling Events",
    "content": "view in sandbox . | React impelemnts its own system of handling events that is very similar to handling events on DOM elements. There are some syntax differences: . | React events are named using camelCase, rather than lower case. | With JSX a function can be passed as an event handler instead of a string. | . | . For example, the HTML . &lt;button onclick=\"incrementCounter()\"&gt;Increment Counter&lt;/button&gt; . is slightly different in React: . &lt;button onclick=\"{incrementCounter}\"&gt;Increment Counter&lt;/button&gt; . | React provides an equivalent of each event that you might be familiar with from standard HTML DOM. Events typing can be imported directly from react as shown in the example below: | . import { MouseEvent } from \"react\"; function HelloWorld() { const sayHello = (event: MouseEvent) =&gt; { event.preventDefault(); console.log(`${event.currentTarget.tagName}: says hello, world.`); }; return ( &lt;div&gt; &lt;button onClick={sayHello}&gt;Submit&lt;/button&gt; &lt;/div&gt; ); } export default HelloWorld; . For the list of all the supported events refer https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/#list-of-event-types . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#handling-events",
    "relUrl": "/tutorials/week4-react-basics#handling-events"
  },"155": {
    "doc": "React Tutorial",
    "title": "React Hooks",
    "content": "React hooks are built-in functions which allows us to use state and other lifecycle features. The most basic hooks used by react are useState() which adds a state variable to a react component and useEffect() which is the lifecycle hook for a component. State of component referes to the data it is holding at a particular moment in time. useState(): . view in sandbox . In this section we will see how we can add state to a React Component using the useState() hook provided by React. The useState hook takes the initial value of the state variable as an argument, the initial state can be any type you want (a string, a number, an array, an object) or a function. Only on the first render will the initial value be assigned. Each useState call returns a two-element array. The state variable is the first element of the array, followed by a function to change the variable’s value. | We’ll start by defining and initializing state for the number of times the button is clicked, by adding the a state variable as follows: | . import {useState} from 'react'; function Counter() { const [count, setCount] = useState(0); ... } . This line of code looks a little strange, so let’s break it down: . | When the hook useState() is invoked, it returns an array. Where the first item is the state value, and the second item is a function that updates the state. | First, we import the useState from react library. | useState is a React function that lets us create state, passing in a default value as a parameter. In our case, we pass it a default value of 0. | The useState function returns an array containing two elements: | . | The first array element contains the current value of state. | . | . | The second array element contains a function to set state to a different value. | . | We destructure the array and store the first array element (the state value) in count, and the second array element (the function to set state) in setCount. | The rest of the function now has access to the count, via the count variable. The function is also able to increment the count, via the setCount variable. | . | Let’s add a function to update the state of the variable: | . function incrementCount() { setCount(count + 1); } . | Now, functions to set the piece of state take in the new state as their parameter. | . | Next we’ll make the component return the count along with a button to increment the count when clicked. Final function code will be as follows: | . import { useState } from \"react\"; function Counter() { const [count, setCount] = useState(0); function incrementCount() { setCount(count + 1); } return ( &lt;div&gt; &lt;h1&gt;Count: {count}&lt;/h1&gt; &lt;button onClick={incrementCount}&gt;Click me!&lt;/button&gt; &lt;/div&gt; ); } export default Counter; . If we give this a try in the running app, we should find the count variable’s value to keep incrementing by one every time the button is clicked. After we’ve got our heads around the code needed to define state, accessing and setting state is fairly simple and elegant. useEffect(): . view in sandbox . Now let’s have a look at how to invoke the code to execute at a certain point in the component’s lifecycle. Older versions of React consisted of different Lifecycle hooks that allowed a user to hook into various phases of component rendering such as componentDidMount, ComponentDidUpdate, etc. which have all been condensed into a single function called useEffect(). Let us observe how this hook behaves by printing out the count in browser console. | As always, we will start by importing the function from the react library: | . import { useEffect } from \"react\"; . | Next we will add the function to our existing counter component: | . useEffect(() =&gt; { console.log(`The current count is ${count}`); }, []); . Let’s break down this code to understand what is happening: . | We use React’s useEffect function to hook into the component life cycle. | The function takes in an arrow function, which executes when the component is first rendered. | The function takes in a second parameter, which determines when our arrow function is called. This parameter is an array of values that, when changed, will cause the arrow function to be invoked. In our case, we pass in an empty array, so our arrow function will never be called after the first render. | If we now try the running app and open the console, we’ll see Counter first rendering only appears once. | . | Let’s remove the second parameter into useEffect now: | . useEffect(() =&gt; { console.log(`The current count is ${count}`); }); . | Now we can see that the componenet will render everytime the value of count is changed. | Additionally we can also pass the variable in the array to observe only changes related to a particular value: | . useEffect(() =&gt; { console.log(`The current count is ${count}`); }, [count]); . | Finally, our component counter will look like: | . import { useState } from \"react\"; import { useEffect } from \"react\"; function Counter() { const [count, setCount] = useState(0); function incrementCount() { setCount(count + 1); } useEffect(() =&gt; { console.log(`The current count is ${count}`); }); return ( &lt;div&gt; &lt;h1&gt;Count: {count}&lt;/h1&gt; &lt;button onClick={incrementCount}&gt;Click me!&lt;/button&gt; &lt;/div&gt; ); } export default Counter; . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics#react-hooks",
    "relUrl": "/tutorials/week4-react-basics#react-hooks"
  },"156": {
    "doc": "React Tutorial",
    "title": "React Tutorial",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week4-react-basics",
    "relUrl": "/tutorials/week4-react-basics"
  },"157": {
    "doc": "Unit Testing with Jest",
    "title": "Understanding Unit Testing",
    "content": "At some point, every programmer has wondered why they should spend time writing test cases instead of focusing on implementing a new feature. The reason for this is that it is important! In this tutorial, we’ll go through several aspects of unit testing, with a focus on utilizing Jest. Before we get into that, let’s define unit testing and why it’s so important in the real world. Unit testing is not a new concept; it has been around for a long time. “Unit tests are often automated tests prepared and executed by software engineers to check that a portion of an application (referred to as a “unit”) matches its design and behaves as expected,” according to Wikipedia. So, to put it another way, it’s a technique to undertake rigorous testing of every single function/module in isolation. Unit testing technques: . | Black Box Testing : It is a process of validating a function’s input and output without any knowledge of it’s internal implementation details. | White Box Testing : Unlike Black Box testing, white box testing focuses on testing the specific internal code flows, uncovering any unidentified error or bug in that component. | Gray Box Testing : Gray Box testing is a combination of the two above wherein partial knowledge of the internal code is needed. This strategy lowers a tester’s reliance on a developer for every minor issue, allowing the tester to detect and resolved it alone. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#understanding-unit-testing",
    "relUrl": "/tutorials/week5-unit-testing#understanding-unit-testing"
  },"158": {
    "doc": "Unit Testing with Jest",
    "title": "Testing with Jest",
    "content": " ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#testing-with-jest",
    "relUrl": "/tutorials/week5-unit-testing#testing-with-jest"
  },"159": {
    "doc": "Unit Testing with Jest",
    "title": "Basics",
    "content": "To understand the basics of unit testing, let us look at the file called ‘calculator.ts’ present in the directory src/services/math/. This file contains a class called Calculator with a method for add() defined as shown below: . // Contents of src/services/math/calculator.ts export default class Calculator { public add(num1: number, num2: number): number { const result: number = num1 + num2; console.log(\"The result is: \", result); return result; } } . Let us write some tests for this code using jest. The test code will go into a file in the same directory titled ‘calculator.spec.ts’. Create this file now. This pattern of ‘file-name.spec.ts’ is how you should name all of your test files when using jest. All test files start with a suite. A suite is a collection of tests (or a logical grouping of tests). In jest, a suite is created by using the function describe(). The suite takes 2 arguments: the 1st being the description of the suite and the second being a callback function. Additionally, suites can be nested to form logical groups. Suites can further be broken down into 3 components that we will explore in detail shortly: . | Setup | Teardown | Test | . Syntax: . describe(\"Description of suite\", () =&gt; { // The tests go here. }); . Suites can be used to make debugging easier when you are using a large number of tests. Here is one recommended suite hierarchy: . | Top level describe should contain the file path after src. | Second describe should contain the name of the Class/File being tested. | Subsequent describe blocks should contain the name of the function being tested. | . Using this hierarchy, the test file for the above example would look as follows: . describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { // Tests for add() go here. }); }); }); . Specs . A spec is an actual test that executes some code and asserts some result. A test is created using the keyword it() or test(). Similar to describe(), it() takes 2 arguments, the first being the description of the test and the second being a callback. Generally, we want to describe what the code should do in the description of it() and assert the described behavior within the test. Each test can be broken down into 3 parts (Assemble, Act, Assert) which makes up the AAA pattern. Optionally, there may be a clean-up/teardown step after the assert. Syntax: . it(\"should check a specific behaviour\", () =&gt; {}); . Let us write a simple test for our add() method to check 1 + 1 = 2. We start by adding a spec to the suite we created previously. describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { // Assemble // Act // Assert }); }); }); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#basics",
    "relUrl": "/tutorials/week5-unit-testing#basics"
  },"160": {
    "doc": "Unit Testing with Jest",
    "title": "Matchers",
    "content": ".toEqual() vs .toBe() vs .toStrictEqual() . All three matchers are used to test equality, though they have slight but important differences. To understand these differences, let us take a look at the example of Store.ts with the below code. export default class Store { private static _data: any = null; public static getData(): any { return Store._data; } public static setData(data: any): void { Store._data = data; } } . | Use .toEqual() to compare recursively all properties of object instances (also known as “deep” equality). It calls Object.is to compare primitive values, which is even better for testing than ‘===’, the strict equality operator. This is the most commonly used matcher. | . describe(\"utils &gt; store\", () =&gt; { describe(\"Store\", () =&gt; { beforeEach(() =&gt; { Store[\"_data\"] = undefined; }); describe(\"setData()\", () =&gt; { it(\"should assign the input data to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store.setData(mockData); expect(Store[\"_data\"]).toEqual(mockData); }); }); describe(\"getData()\", () =&gt; { it(\"should return an object equal to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); }); }); }); }); . | Use .toBe() to compare primitive values or to check referential identity of object instances. It calls Object.is to compare values, which is even better for testing than ‘===’, the strict equality operator. | . describe(\"getData()\", () =&gt; { it(\"should return an object with a reference different to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); expect(returnedValue).not.toBe(mockData); expect(Store[\"_data\"]).toBe(mockData); }); }); . | Use .toStrictEqual() to test that objects have the same types as well as structure. This checks for undefined in Objects and sparseness in Arrays. | { key: undefined } is not strictly equal to { }. | [ , 1] is not strictly equal to [undefined, 1]. | . | . it(\"should return an object strictly equal to object stored in Store._data\", () =&gt; { const mockData = { key: \"value\" }; const mockDataWithUndefined = { key: \"value\", key2: undefined }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toStrictEqual(mockData); expect(returnedValue).toEqual(mockDataWithUndefined); expect(returnedValue).not.toStrictEqual(mockDataWithUndefined); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#matchers",
    "relUrl": "/tutorials/week5-unit-testing#matchers"
  },"161": {
    "doc": "Unit Testing with Jest",
    "title": "AAA",
    "content": "Assemble . In order to run a test, we need to first assemble it. This may include creating instances of classes/variables, setting up test data for inputs, setting up spies/stubs/mocks (which will be covered in subsequest sections), or setting up the expected output. In simple cases, one may not need to assemble the test. This phase is very similar to the setup phase. In our example, let us create an instance of the Calculator class as part of assembling the test. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); // Act // Assert }); }); }); }); . Act . In this step, we actually execute the function under test with required inputs and get the returned result (if any). In our example, we will invoke the add() method with inputs (1, 1) and get the result. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); // Assert }); }); }); }); . Assert . Assertion is a statement that validates the behavior of our code by comparing the actual result against the expected results. There are many assertions provided by Jest, including some useful assertions we will use throughout our tests. Some of these assertions are listed below: . | expect(actual).toEqual(expected) // Expects both entities to have the same value. | expect(actual).toBe(expected) // Expects both entities to be the same. | expect(spy/stub/mock).toHaveBeenCalled() // Expects a function being spied/stubbed/mocked to be invoked. | expect(spy/stub/mock).toHaveBeenCalledWith([arguments]) // Expects a function being spied/stubbed/mocked to be invoked with specified arguments. | expect(actual).toBeDefined() // Expects the entity to be defined. | expect(actual).not. // Negates the assertion. Can be chained with any matchers above | await expect(error causing code returning a promise).rejects.toThrowError() // Waits for the error throwing code that returns promise (e.g. an API call) to throw the error and asserts the error was thrown. | . A full list of matchers can be found here. In our example, we can use the .toEqual() matcher. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#aaa",
    "relUrl": "/tutorials/week5-unit-testing#aaa"
  },"162": {
    "doc": "Unit Testing with Jest",
    "title": "Setup and Teardown",
    "content": "Often in tests, we need some things to happen before a test actually runs and some things to happen after it. This may include resetting/initializing values, setting up test data, setting up spies/stubs/mocks, cleaning up variables after a test, or resetting spies/stubs/mocks. Sometimes these steps may need to be repeated for each test. This is where the setup and teardown can be especially useful. Jest Provides 2 methods for setup and 2 methods for teardown: . | beforeAll(): Runs one time before all the tests in a suite. | beforeEach(): Runs before every test in a suite. | afterEach(): Runs after every test in a suite. | afterAll(): Runs once after all tests in a suite. | . In our example, notice we created an instance of calculator in our Assemble phase. We will probably have multiple tests for the calculator that will require this instance. In order to avoid repeating this in every step, let us move this to the setup phase and add a teardown to clear this after all tests. Note: Use beforeEach()/afterEach() if the function/class stores state, and we need a clean instance for each test. In our case, calculator does not store any state, and we can share the same instance across tests with out any side effects. Hence, we will use beforeAll()/afterAll(). import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { calculator = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . Let us add another test to cover a different scenario, such as adding negative numbers. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { calculator = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); it(\"should return -2 when inputs are -1 and -1\", () =&gt; { const result: number = calculator.add(-1, -1); expect(result).toEqual(-2); }); }); }); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#setup-and-teardown",
    "relUrl": "/tutorials/week5-unit-testing#setup-and-teardown"
  },"163": {
    "doc": "Unit Testing with Jest",
    "title": "Mock Testing",
    "content": "As a project grows so do the interdependencies in the project. A function under test can have dependencies from various external entities. This may include other functions, network requests, database connections, or built-in connections. Spies, Stubs, and Mocks are ways of dealing with such external dependencies. You can read more on what you can do with spies/stubs/mocks here. Spy . A spy is a watcher on a function that tracks various properties of the function being spied on. This can return information such as whether a function was invoked, how many times it was invoked, and what argument it was invoked with. A spy on a function is created using the syntax const spy = jest.spyOn(object, 'methodName'); . Note: The function being spied on actually executes. In our example, we have an external dependency on console.log(). Let us add a spy and test for it. import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { calculator = undefined; }); it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(window.console, \"log\"); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); }); }); }); . Mock . A mock is function which replaces an existing function. In our example, if we wanted to change the behavior of console.log() for our tests, we can do so using a mock. A mock implementation can be substituted for a spy or a jest.fn(). The syntax is as below: . spy.mockImplementation(() =&gt; { // new function body goes here. }); . Note: The function being mocked does not execute. In our example, if we wanted to replace the behavior of console.log(), we can do so as shown: . it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(window.console, \"log\"); logSpy.mockImplementation(() =&gt; { // This will no longer print to console. }); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . Warning: Watch out for circular dependencies in mock implementations. Stub . A stub is a special kind of mock which does not require an alternate implementation but instead returns some value that we specify. When a stub gets invoked, it does not invoke the actual function, but returns the desired value instead. The syntax is as below: . spy.mockReturnValue(someValue); . To return a promise, we can use: . spy.mockResolvedValue(someValue); . This can be especially handy when stubbing Axios requests. Using a stub in our example simply prevents console.log() from being executed, since it does not return a value anyway. it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = jest.spyOn(window.console, \"log\"); logSpy.mockReturnValue(); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#mock-testing",
    "relUrl": "/tutorials/week5-unit-testing#mock-testing"
  },"164": {
    "doc": "Unit Testing with Jest",
    "title": "Testing Asynchronous Code",
    "content": "Promise . In previous tutorials, we have used Axios to make http requests which return promises. This is how we can write tests for axios requests. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } } . We can test the above code as follows: . // Assuming we have done the setup as in previous tests describe(\"getData()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getData(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should return the status as 200\", async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); const response = await httpService.getData(); expect(response.status).toEqual(200); getStub.mockRestore(); }); }); . Note: You can return different values for subsequent calls to a stub. Occasionally, you may run into situations where an http request is made but no promise is returned. This is often found in cases involving “fire and forget” calls or a central store with an Observable pattern implementation (e.g. Redux with react). We cannot await a function that does not return a promise. However, we can use fake timers to simulate passage of time to test such asynchronous behavior. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } public getDataAndSetStore(): void { axios.get(\"/myUrl\").then((res) =&gt; { Store.setData(res.data); }); } } . We can test the above functionality as follows: . describe(\"getDataAndSetStore()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getDataAndSetStore(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should set the data in store\", async () =&gt; { const addDataStub = jest.spyOn(Store, \"setData\").mockImplementation(); const getStub = jest .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: \"myData\" }); jest.useFakeTimers(); httpService.getDataAndSetStore(); jest.runAllTimers(); await Promise.resolve(); expect(addDataStub).toHaveBeenCalledWith(\"myData\"); addDataStub.mockRestore(); getStub.mockRestore(); jest.useRealTimers(); }); }); . Callbacks . Callbacks are one of the most commonly used patterns for asynchronous programming in JavaScript/TypeScript. Consider the below callback function use case: . test('Check if I am a true husky', () =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); } fetchData(callback); }); . Here, fetchData() is a function that takes a callback and would call that callback function later in it’s implementation. Now consider 2 scenarios: . case 1: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am from Northeastern!'); }, 1000); } . case 2: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am not from Northeastern!'); }, 1000); } . The test case would still pass in either of the above scenarios since fetchData() is an async function, which means the program will not wait for the call to complete. The correct way to test a callback would be using the argument done in the test like shown in below example: . test('Check if I am a true husky', (done) =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); done(); } fetchData(callback); }); . Now, the program would wait for done to be invoked. This implementation would correctly test both the above scenarios. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#testing-asynchronous-code",
    "relUrl": "/tutorials/week5-unit-testing#testing-asynchronous-code"
  },"165": {
    "doc": "Unit Testing with Jest",
    "title": "Setting up testing using Jest in VSCode",
    "content": "Testing can sometimes get cumbersome as the user is expected to remember all the options provided by Jest to run a specific set of tests, or otherwise the user will have to run the entire test suite just to verify the result of a single test case. Not anymore! . With vscode-jest, you have complete control over the way you want to run tests, with many features that visually inform the users about which specific line is failing with what error. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#setting-up-testing-using-jest-in-vscode",
    "relUrl": "/tutorials/week5-unit-testing#setting-up-testing-using-jest-in-vscode"
  },"166": {
    "doc": "Unit Testing with Jest",
    "title": "Features",
    "content": ". | Starts Jest automatically when you’re in a root folder project with Jest installed. | Show individual fail / passes inline. | Show fails inside the problem inspector. | Highlights the errors next to the expect functions. | Adds syntax highlighting to snapshot files. | A one button update for failed snapshots. | Show coverage information in files being tested. | Help debug jest tests in vscode. | Supports multiple test run modes (automated, manual, and hybrid onSave) to meet user’s preferred development experience. | Track and shows overall workspace/project test stats | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#features",
    "relUrl": "/tutorials/week5-unit-testing#features"
  },"167": {
    "doc": "Unit Testing with Jest",
    "title": "Installation",
    "content": "Direct Installation . | Open Visual Studio Code, go to the extension tab. | Search for “Jest” with the publisher name as “Orta”. | Click “Install”. | . From Visual Studio Marketplace . | Visit Jest - Visual Studio Marketplace and click “Install”. | Allow the browser to open VSCode as shown (might be different for macOS/Linux systems) by clicking on Continue. | Once VSCode is open, click on “Install”. | . Once installed, the extension should work out of the box without any extra configuration for most of the homework handouts and project starter code. You can verify the installation by checking if the following is visible to you when you open a project which has Jest configured (VSCode restart maybe required.). If restarting Jest does not work, you can run the following in your VSCode by opening VSCode’s command palette (Ctrl + Shift + P in Windows, Cmd + Shift + P in macOS) and run the following - “Jest: Start All Runners”. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#installation",
    "relUrl": "/tutorials/week5-unit-testing#installation"
  },"168": {
    "doc": "Unit Testing with Jest",
    "title": "Configuration",
    "content": "As of the latest stable version, the extension is set to run all tests whenever any change is made to the files containing the tests. You can modify the behaviour to manual execution where you can run specific test cases as and when required. This can be modified by changing the \"jest.autoRun\" setting as follows - . | \"jest.autoRun\": {\"watch\": true} =&gt; will start the jest with the watch flag and leave all tests at “unknown” state until changes are detected. | \"jest.autoRun\": {\"watch\": true, \"onStartup\": [\"all-tests\"]} =&gt; will start running all tests upon project launch to update overall project test stats, followed by the jest watch for changes. | \"jest.autoRun\": \"off\" =&gt; there will be no automatic test run, users will trigger test run by either command or context-menu. | \"jest.autoRun\": {\"watch\": false, \"onSave\": \"test-file\"} =&gt; the extension will trigger test run for the given test file upon save. | \"jest.autoRun\": {\"watch\": false, \"onSave\": \"test-src-file\"} =&gt; the extension will trigger test run for the given test or source file upon save. | . An example of changing the extension to run in manual mode is demonstrated below - . NOTE - You will only be able to Run specific test cases as and when required only when autoRun is off. However, you’ll be able to Debug any test cases in all available modes. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#configuration",
    "relUrl": "/tutorials/week5-unit-testing#configuration"
  },"169": {
    "doc": "Unit Testing with Jest",
    "title": "Debugging Tests",
    "content": "Once the extension is setup and confirmed to be working, we can now begin debugging the tests. You can do so by opening the testing tab from the left sidebar in VSCode to view all the tests present in the current project. You can also navigate to the specific test file manually, and you will notice some icons/action buttons in the editor next to each test. Right clicking on the icons will bring up a test-specific context menu which will have options to debug the specific test. Be sure to place breakpoints in the specific pieces of code by clicking to the left of the line numbers. If everything is setup correctly, the debugger in VSCode will pause at the breakpoint you set and you can check the values of the variables by hovering over the said variable. ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#debugging-tests",
    "relUrl": "/tutorials/week5-unit-testing#debugging-tests"
  },"170": {
    "doc": "Unit Testing with Jest",
    "title": "General Guidelines For Writing Tests",
    "content": "Note: The following will be used as a reference when grading assignments. | Tests should be hermetic. | Reduce flakiness. | Flaky tests are those that fail intermittently: . | Nondeterminism (e.g., hash codes, random numbers); | Timing issues (e.g., threads, network). | Availability of Resources | . | . | Tests should be clear. | After failure, should be clear what went wrong. | . | Tests should be scoped as small as possible. | Faster and more reliable. | . | Tests should make calls against public APIs. | Or they become brittle | Brittle tests are those that are not self-contained: . | Ordering of tests (e.g., assume prior state) | . | . | . Note: The following will not be used as a reference when grading assignments. But you should try following these guidelines as much as you can. | Write tests based on the expected behavior, not based on the interpretation/implementation of it. | Test assertion (expect) should match the test description. | Each spec should test only 1 thing (preferably with 1 assertion per test). | Organize tests using suites (i.e. each method has it’s own suite). | Use setup and teardown functions to reduce code duplicity. | Code duplicity in tests is preferred over complicated logic to reduce it. | If your tests need tests, they have no value. | . | Cover the happy path for your code first. | Follow up with edge cases. | End with error scenarios. | . | Mock/Stub all external dependencies. | Clear the mocks after each test. | . | If large test data is being used, ensure clean-up after tests to prevent memory leaks. | Code coverage is a deceptive measure. 100% coverage does not mean 100% tested code. | A well designed test suite improves the quality and reliability of code. | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing#general-guidelines-for-writing-tests",
    "relUrl": "/tutorials/week5-unit-testing#general-guidelines-for-writing-tests"
  },"171": {
    "doc": "Unit Testing with Jest",
    "title": "Unit Testing with Jest",
    "content": "This tutorial covers the basics on unit testing with Jest. By the end of this tutorial, you will have an introduction to unit testing with jest, best practices, and some handy tricks and tips to use in your tests. Starter code is available here, and finished code with tests covered in this tutorial can be found here. We strongly recommend using the completed solution only for reference and implementing the tutorial step by step from the starter code. Contents: . | Understanding Unit Testing | Testing with Jest . | Basics . | Specs | . | Matchers . | .toEqual() vs .toBe() vs .toStrictEqual() | . | AAA . | Assemble | Act | Assert | . | Setup and Teardown | Mock Testing . | Spy | Mock | Stub | . | Testing Asynchronous Code . | Promise | Callbacks | . | . | Setting up testing using Jest in VSCode . | Features | Installation . | Direct Installation | From Visual Studio Marketplace | . | Configuration | Debugging Tests | . | General Guidelines For Writing Tests | . ",
    "url": "https://neu-se.github.io/CS4530-Fall-2022/tutorials/week5-unit-testing",
    "relUrl": "/tutorials/week5-unit-testing"
  }
}
